{"./":{"url":"./","title":"Introduction","keywords":"","body":"Android知识体系 "},"Android开发常见问题.html":{"url":"Android开发常见问题.html","title":"Android开发常见问题","keywords":"","body":"Android开发问题和经验总结（不断更新中） 安卓常见问题，Bug等以及解答，欢迎大家更新和指正！！！ Android 系统 防止OOM： 8.0之后对内存使用方式做了修改，这两个操作就可以避免全部的oom： minSdk 26 ndk {abiFilters 'arm64-v8a'} Android 9 Http请求：Cleartext HTTP traffic to ... not permitted 方案1：改用https 方案2：targetSdkVersion 降到27以下 方案3：更改网络安全配置（1） 1.在res文件夹下创建一个xml文件夹，然后创建一个network_security_config.xml文件，文件内容如下： 2.接着，在AndroidManifest.xml文件下的application标签增加以下属性： 方案4：更改网络安全配置（2）：直接在AndroidManifest.xml配置文件的标签中直接插入android:usesCleartextTraffic=\"true\" View 问题 TextView singleLine过时了，使用lines代替。maxLines=“1”不能限制文本只显示一行 string资源字符串自定义部分文本颜色 //string.xml中配置： %s染色]]> //TextView设置： TextView.setText(Html.fromHtml(getString(id, \"format\"))) EditText Java代码中调用了setFilters，会覆盖布局中maxLength属性，除非同时设置了LengthFilter InputType问题 布局中inputType和xml中设置setInputType()使用有差异：例：xml中inputType=number，代码中不是设置TYPE_XXX_VARIATION_YYY，而是要设置TYPE_CLASS_XXX | TYPE_XXXX_VARAITION_YYY 比如xml中android:inputType=\"textPassword\"，效果相当于et.setInputType(InputType.TYPE_TEXT_VARIATION_PASSWORD | InputType.TYPE_CLASS_TEXT); 键盘和输入内容都限制了 CheckBox button属性失效问题 button对应的Selector drawable，把选中和未选中状态单独放到一个drawable中，不然和selected等混在一个文件会失效 RecyclerView java.lang.IndexOutOfBoundsException: Inconsistency detected. Invalid item position... RecyclerView绑定的 List 对象在更新数据之前进行了 clear，而这时紧接着迅速上滑 RecyclerView，就会造成崩溃，属于RecyclerView内部异常。 RecyclerView在多层嵌套的内容中，即使设置了wrap_content或者match_parent,但是数据项还是只显示1行，Item高度也不是wrap_content 使用可以让RecyclerView显示全的控件进行包裹，推荐使用NestedScrollView。（本人在项目中遇到这个问题，Recyclerview外层是多层LinearLayout, CardView等布局，还要在外层加上下拉刷新的功能。网上多种解决方案都试过，也没有采用inflate(layoutId, null, false)加载Item的方法，因为封装过Adapter再改代价很大。最后的解决方案是：在RecyclerView外层布局包裹NestedScrollView，禁用RecyclerView滑动，使用NestedScrollView的滑动即可[本人使用的下拉刷新是SmartRefreshLayout，内部使用NestedScrollView可以正常滑动，问题解决]） ScrollView嵌套RecyclerView的显示不全，滑动卡顿，夺取了焦点导致页面启动时RecyclerView上方布局没显示问题 有问题的代码： 滑动卡顿问题： recyclerView.setHasFixedSize(true); recyclerView.setNestedScrollingEnabled(false); 或者 android:nestedScrollingEnabled=\"false\" RecyclerView夺取焦点问题：外层布局需要增加属性（但是某些时候这个属性不起作用） android:focusable=\"true\" android:focusableInTouchMode=\"true\" RecyclerView夺取焦点问题解决方案2：ScrollView的直接子View使用 //截获RecyclerView焦点 android:descendantFocusability=\"blocksDescendants\" //android:descendantFocusability属性： beforeDescendants：viewgroup会优先其子类控件而获取到焦点 afterDescendants：viewgroup只有当其子类控件不需要获取焦点时才获取焦点 blocksDescendants：viewgroup会覆盖子类控件而直接获得焦点 显示不全的问题：使用NestedScrollView代替ScrollView //没有问题的代码： LinearLayout嵌套RecyclerView的显示不全，滑动卡顿，夺取了焦点导致页面启动时RecyclerView上方布局没显示问题（真实情况应是ScrollView嵌套LinearLayout嵌套RecyclerView会出现） 附上之前出问题的代码（问题已经改了）： 解决方案是在RecyclerView外包裹RelativeLayout。原因：ScrollView嵌套RecyclerView解决以及原理详解 文中提到LinearLayout和RelativeLayout测量的不同 DiffUtil.Callback RecyclerView动态更新/增减数据需要实现的类 部分(partial)绑定vs完整(full)绑定 payloads 参数 是一个从（notifyItemChanged(int, Object)或notifyItemRangeChanged(int, int, Object)）里得到的合并list。 如果payloads list 不为空，那么当前绑定了旧数据的ViewHolder 和Adapter， 可以使用 payload的数据进行一次 高效的部分更新。 如果payload 是空的，Adapter必须进行一次完整绑定（调用两参方法）。 需要实现的方法：DiffUtil.Callback：public Object getChangePayload(int oldItemPosition, int newItemPosition)， RecyclerView.Adapter：public void onBindViewHolder(VH holder, int position, List payloads) ScrollView 滚动到顶部或者底部 ： scrollView.fullScroll(ScrollView.FOCUS_DOWN);滚动到底部 scrollView.fullScroll(ScrollView.FOCUS_UP);滚动到顶部 滚动到顶部的三种方式： ScrollView.scrollTo(``0``,``0``);``//直接置顶，瞬间回到顶部，没有滚动过程，其中Y值可以设置为大于0的值，使Scrollview停在指定位置。 ScrollView.fullScroll(View.FOCUS_UP);``//类似于手动拖回顶部,有滚动过程 ScrollView.smoothScrollTo(``0``, ``0``);``//类似于手动拖回顶部,有滚动过程，其中Y值可以设置为大于0的值，使Scrollview停在指定位置。 ViewPager Item切换重建（主要是和Fragment搭配使用时，切换到第三个页面，第一个页面销毁） 通过setOffscreenPageLimit防止频繁销毁（setOffscreenPageLimit注释：设置当前page左右两侧应该被保持的page数量，超过这个限制，page会被销毁重建（只是销毁视图），onDestroy-onCreateView,但不会执行onDestroy。尽量维持这个值小，特别是有复杂布局的时候，因为如果这个值很大，就会占用很多内存，如果只有3-4页的话，可以全部保持active，可以保持page切换的顺滑 Tools命名空间的使用 xmlns:tools=\"http://schemas.android.com/tools\" tools命名空间中的各种XML属性，这些属性支持设计时功能（例如，在片段中显示哪种布局）或编译时行为（例如应用于XML资源的缩小模式）。构建应用程序时，构建工具会删除这些属性，因此不会影响APK大小或运行时行为。 错误处理属性 tools:ignore 用于：任何元素 使用者：Lint 此属性接受以逗号分隔的lint问题ID列表，用于忽略指定的错误 例如，忽略MissingTranslation错误： All tools:targetApi 用于：任何元素 使用者：Lint 此属性与@TargetApiJava代码中的注释相同 ：它允许指定支持此元素的API级别（作为整数或代码名称）。 表名此元素（以及任何子元素）将仅在指定的API级别或更高级别上使用。用于阻止lint警告 例如，指定 GridLayout仅适用于API级别14及更高版本： tools:locale 用于： 使用者：Lint，Android Studio编辑器 这告诉工具给定元素中的资源的默认语言/语言环境是什么（因为工具否则假定为英语），以避免来自拼写检查器的警告。该值必须是有效的 区域设置限定符。 例如，将其添加到values/strings.xml文件（默认字符串值），以指示用于默认字符串的语言是西班牙语而不是英语： 设计时视图属性——仅在Android Studio布局预览中可见的布局特征 tools: 代替 android: 用于： 使用者：Android Studio布局编辑器 可以使用tools:前缀而不是Android框架中的android:任何属性在布局预览中插入示例数据。当在App运行之前未填充属性的值，但你希望在布局预览中预先看到效果时，这非常有用。 例如，如果android:text属性值是在运行时设置的，或者你希望看到布局的值不同于默认值，则可以添加 tools:text以仅为布局预览指定一些文本。 图1.该tools:text属性将“Google Voice”设置为布局预览的值 你可以添加android:命名空间属性（在运行时使用）和匹配tools:属性（仅在布局预览中覆盖运行时属性）。或者仅使用tools:属性用于布局预览。例如： tools:context 用于：任何根 使用者：Lint，Android Studio布局编辑器 此属性声明默认情况下此布局与哪个Activity相关联。比如导入View.onClick方法到次Activity。 tools:itemCount 用于： 使用者：Android Studio布局编辑器 对于给定的RecyclerView，此属性指定布局编辑器应在“ 预览”窗口中呈现的条目数 。 例如： tools:layout 用于： 使用者：Android Studio布局编辑器 此属性声明你希望布局预览在Fragment内绘制的布局（因为布局预览无法执行通常应用布局的活动代码）。例如： tools:listitem / tools:listheader / tools:listfooter 用于:( 及其子类，比如） 使用者：Android Studio布局编辑器 这些属性指定在列表的条目，页眉和页脚的布局预览中显示的布局。布局中的任何数据字段都填充了数字内容，例如“项目1”，以便列表项不重复。 例如： tools:showIn 用于：布局根需要嵌入并一同显示预览的布局 使用者：Android Studio布局编辑器 此属性将会把当前布局嵌入其引用的布局一同显示预览。例如： 资源收缩属性 shrinkResources 的使用参考 minifyEnabled 用来开启删除无用代码，比如没有引用到的代码 shrinkResources 用来开启删除无用资源，也就是没有被引用的文件（经过实测是drawable,layout，实际并不是彻底删除，而是保留文件名，但是没有内容，等等），但是因为需要知道是否被引用所以需要配合mififyEnable使用，只有当两者都为true的时候才会起到真正的删除无效代码和无引用资源的目的。例如： android { ... buildTypes { release { //收缩资源 shrinkResources true //代码混淆 minifyEnabled true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' } } } tools:shrinkMode 用于： 使用者：资源缩减构建工具 此属性允许你指定构建工具是否应使用“安全模式”（保护安全并保留所有明确引用的资源以及可能通过调用动态 引用的资源Resources.getIdentifier())）或“严格模式”（仅保留资源）在代码或其他资源中明确引用）。 默认是使用安全模式（shrinkMode=\"safe\"）。要改为使用严格模式，需更改为shrinkMode=\"strict\"到节点，如下所示： 启用严格模式时，你可能需要使用tools:keep 以保留已删除但实际需要的资源，并用于 tools:discard显式删除更多资源。 有关更多信息，请参阅 缩小资源。 tools:keep 用于： 使用者：资源缩减构建工具 此属性用于指定你需要保留的资源（通常是因为它们在运行时以间接方式引用，例如通过将动态生成的资源名称传递给 Resources.getIdentifier())）。 用法：在资源目录（例如，at res/raw/keep.xml）中使用标记创建XML文件， 并将要保留在tools:keep属性中的每个资源指定为以逗号分隔的列表。可以将星号字符用作通配符。例如： tools:discard 用于： 使用者：资源缩减构建工具 此属性用于指定你需要手动丢弃的资源（通常是因为资源被引用但不会影响你的应用，或者因为Gradle插件错误地推断出资源被引用）。 用法：在资源目录（例如，at res/raw/keep.xml）中使用标记创建XML文件， 并将要保留在tools:discard属性中的每个资源指定为以逗号分隔的列表。可以将星号字符用作通配符。例如： Style问题 declare-styleable format可选项 \"reference\"//引用 \"color\"//颜色 \"boolean\"//布尔值 \"dimension\"//尺寸值 \"float\"//浮点值 \"integer\"//整型值 \"string\"//字符串 \"fraction\"//百分数,比如200% \"enum\" 枚举值 //enum枚举例子 Activity等系统组件 Activity切换时，短暂白屏问题，主要是启动singleTask或者singleInstance标志的Activity，同时关闭当前Activity，大概率出现这个问题 Activity theme加上 true 即可。 这个标志应该也可以 true ，然后onCreate应该需要去掉这个标志。 moveTaskToBack(boolean) 点返回键时，把App移到后台，而不是退出 参数为false——代表只有当前activity是task根，指应用启动的第一个activity时，才有效; 参数为true——则忽略这个限制，任何activity都可以有效。 判断Activity是否是task根，Activity本身给出了相关方法：isTaskRoot() 把App移到后台，而不是退出，最简单无脑的使用方法：MainActivity，重写onBackPressed如下，即可实现 override fun onBackPressed() { moveTaskToBack(true) } Activity设置为Dialog样式 方案： Activity Theme设置为： 不使用true，而使用parent=\"@style/Theme.AppCompat.DayNight.Dialog\"的原因是因为在页面上输入框会被软键盘遮住，软键盘不会顶起输入法 @null true &lt;!&ndash; 浮在activity之上 &ndash;&gt;--> false true true @android:color/transparent @android:color/transparent true 布局：android:minWidth或者android:layout_width设置为很大的dp，防止宽度太小的问题 防止点击空白处页面关闭，Activity中调用： setFinishOnTouchOutside(false); 这个方案也有不完美的地方（应该算系统问题），布局较高，输入框靠下时，获取到焦点窗口上移时会被截断。但是不算大问题。 MainActivity打开新的Activity，因点击触发异常后（直接onCreate抛异常App会直接死掉），返回当前Activity时，Fragment重叠问题 新Activity强退，导致MainActivity重新走了生命周期（onCreate-onStart-onResume）Activity保存了Fragment状态，在onCreate中savedInstanceState!=null，里头保存了Fragment状态： android:support:fragments=android.support.v4.app.FragmentManagerState@ab76c10, android:fragments=android.app.FragmentManagerState@7661309}] 方案： //方案1：super.onCreate(null); 传null解决 @Override protected void onCreate(@Nullable Bundle savedInstanceState) { //解决Activity重建Fragment重叠问题 super.onCreate(null); } //方案2：按需清除Bundle中FragmentManagerState 输入法遮挡输入框问题 通用解决方法：AndroidManifest中Activity的windowSoftInputMode属性来调整 通用解决方法无法解决，主要是自定义软键盘的情况 ScrollView中的EditText被自定义输入法遮挡： ScrollView子控件最后增加一个空布局，比如Space，默认隐藏；界面显示后，计算Space高度：软键盘高度-输入框底部距离当前Activity窗口底部距离，>0时，就是有遮挡问题。 监听自定义软键盘弹出/隐藏，或者输入框是否获得焦点，如果软键盘弹出/输入框获得焦点，显示Space，调用nestedScrollView.scrollTo(0, space.getHeight())，解决遮挡问题；软键盘隐藏时，隐藏Space Dialog宽度不够问题 Dialog布局外层包裹一层RelativeLayout即可。 Kotlin 专题 Kotlin data class 和 Gson, @parcelize问题 gson 扩展方法 inline fun Gson.fromJson(json: String) = fromJson(json, T::class.java) @parcelize 需要在build.gradle android内设置属性 ​ androidExtensions { experimental = true } 例子： //正确的data class写法 @Parcelize data class Student( var age: Int = 0, var name: String? = null, var toy: Toy? = null ) : Parcelable { } @Parcelize data class Toy( var price: Int = 0, var name: String? = null ) : Parcelable { } //错误的data class写法，类体内的name不会序列化，别的地方使用获取到的是null，kotlin bytecode，decompile文件可以看到 @parcelize data class Student( var age: Int = 0): Parcelable { var name: String? = null } gson解析 val student2 = gson.fromJson(\"{\\n\" + \"\\t\\\"age\\\":10,\\n\" + \"\\t\\\"name\\\":\\\"json name\\\",\\n\" + \"\\t\\\"toy\\\":{\\n\" + \"\\t\\t\\\"name\\\":\\\"toy\\\",\\n\" + \"\\t\\t\\\"price\\\":1000\\n\" + \"\\t}\\n\" + \"}\", Student::class.java) intent.putExtra(\"student2\", student2) 指定Java调用的类名，要用到注解 @file:JvmName(),放在package之前 也就是要写成这样，剩下的就直接改变代码里的类名就可以了。 @file:JvmName(\"Hello\") package kotlin @file:JvmName(\"Utils\") 和 @file:JvmMultifileClass 一起使用的场景： //在需要合并的每个Kotlin文件加入如下属性： @file:JvmName(\"Utils\") @file:JvmMultifileClass demo: // oldutils.kt @file:JvmName(\"Utils\") @file:JvmMultifileClass package demo fun foo() { } //___________________________________________________________ // newutils.kt @file:JvmName(\"Utils\") @file:JvmMultifileClass package demo fun bar() { } //__________________________________________________________ // build后，在Java文件中的调用方法： Utils.foo(); Utils.bar(); 编写和Kotlin代码文档（相当于Javadoc） 生成文档 Kotlin 的文档生成工具称为 Dokka。其使用说明请参见 Dokka README。 Dokka 有 Gradle、Maven 和 Ant 的插件，因此你可以将文档生成集成到你的构建过程中。 "},"Android工具/readme.html":{"url":"Android工具/readme.html","title":"Android工具","keywords":"","body":"Android工具 "},"Android工具/logcat.html":{"url":"Android工具/logcat.html","title":"Logcat","keywords":"","body":"Logcat 优先级 V — 详细（最低优先级） D — 调试 I — 信息 W — 警告 E — 错误 A — 断言 通过代码记录日志 `常用的日志记录方法包括： Log.v(String, String)（详细） Log.d(String, String)（调试） Log.i(String, String)（信息） Log.w(String, String)（警告） Log.e(String, String)（错误） 例如，使用以下调用： Log.i(\"MyActivity\", \"MyClass.getView() — get item number \" + position); logcat 输出类似于如下： I/MyActivity( 1557): MyClass.getView() — get item number 1 通过Android Studio查看和过滤日志 "},"Android工具/adb.html":{"url":"Android工具/adb.html","title":"ADB和ADB idea","keywords":"","body":"ADB和ADB idea 查看前台Activity adb shell dumpsys activity activities | grep mFocusedActivity adb version 查看版本 adb devices 查看连接设备 adb install 安装 adb uninstall 卸载 adb start-server 启动Server adb kill-server 停止Server adb logcat 查看日志 adb get-serialno 获取序列号 adb shell pm list packages 列出所有包名 adb shell pm list packages -s 列出系统包名 adb shell pm list packages -3 列出第三方包名 adb shell pm list packages | grep qq grep过滤 adb shell pm clear 清除应用数据 adb shell cat /sys/class/net/wlan0/address 获取MAC地址 adb shell getprop ro.product.model 查看设备型号 adb shell getprop ro.build.version.release 查看Android版本 adb shell wm size 查看分辨率 adb shell wm density 查看屏幕密度 无线连接，需要借助USB线 adb tcpip 8888 adb connect ip:8888 adb disconnect ip:8888 查看应用列表： adb shell pm list packages [-f] [-d] [-e] [-s] [-3] [-i] [-u] [--user USER_ID] [FILTER] 查看所有应用 adb shell pm list packages 安装APK adb install [-lrtsdg] adb install 后面可以跟一些可选参数来控制安装 APK 的行为，可用参数及含义如下： 参数 含义 -l 将应用安装到保护目录 /mnt/asec -r 允许覆盖安装 -t 允许安装 AndroidManifest.xml 里 application 指定 android:testOnly=\"true\" 的应用 -s 将应用安装到 sdcard -d 允许降级覆盖安装 -g 授予所有运行时权限 卸载apk adb uninstall [-k] 表示应用的包名，-k 参数可选，表示卸载应用但保留数据和缓存目录。 "},"四大组件/readme.html":{"url":"四大组件/readme.html","title":"四大组件","keywords":"","body":"四大组件 "},"四大组件/Activity.html":{"url":"四大组件/Activity.html","title":"Activity","keywords":"","body":"Activity 生命周期 创建和使用 继承Activity，或者ListActivity, AppCompatActivity, PreferenceActivity等，在清单文件注册，调用startActivity(new Intent(context, YourActivity.class)) 启动你的Activity, 调用finish()关闭Activity。可使用startActivityForResult 接收Activity结果 隐式启动Activity，以及获取 Activity 的结果 启动模式 standard 模式启动模式，每次激活Activity时都会创建Activity，并放入任务栈中。 singleTop 如果在任务的栈顶正好存在该Activity的实例， 就重用该实例，否者就会创建新的实例并放入栈顶(即使栈中已经存在该Activity实例，只要不在栈顶，都会创建实例)。 singleTask 如果在栈中已经有该Activity的实例，就重用该实例(会调用实例的onNewIntent())。重用时，会让该实例回到栈顶，因此在它上面的实例将会被移除栈。如果栈中不存在该实例，将会创建新的实例放入栈中。 singleInstance 在一个新栈中创建该Activity实例，并让多个应用共享改栈中的该Activity实例。一旦改模式的Activity的实例存在于某个栈中，任何应用再激活改Activity时都会重用该栈中的实例，其效果相当于多个应用程序共享一个应用，不管谁激活该Activity都会进入同一个应用中。 处理状态变更 保存Activity状态 管理 Activity 生命周期的引言部分简要提及，当 Activity 暂停或停止时，Activity 的状态会得到保留。 确实如此，因为当 Activity 暂停或停止时，Activity 对象仍保留在内存中 — 有关其成员和当前状态的所有信息仍处于活动状态。 因此，用户在 Activity 内所做的任何更改都会得到保留，这样一来，当 Activity 返回前台（当它“继续”）时，这些更改仍然存在。 不过，当系统为了恢复内存而销毁某项 Activity 时，Activity 对象也会被销毁，因此系统在继续 Activity 时根本无法让其状态保持完好，而是必须在用户返回 Activity 时重建 Activity 对象。但用户并不知道系统销毁 Activity 后又对其进行了重建，因此他们很可能认为 Activity 状态毫无变化。 在这种情况下，您可以实现另一个回调方法对有关 Activity 状态的信息进行保存，以确保有关 Activity 状态的重要信息得到保留：onSaveInstanceState()。 系统会先调用 onSaveInstanceState()，然后再使 Activity 变得易于销毁。系统会向该方法传递一个 Bundle，您可以在其中使用 putString() 和putInt() 等方法以名称-值对形式保存有关 Activity 状态的信息。然后，如果系统终止您的应用进程，并且用户返回您的 Activity，则系统会重建该 Activity，并将 Bundle 同时传递给 onCreate() 和 onRestoreInstanceState()。您可以使用上述任一方法从 Bundle 提取您保存的状态并恢复该 Activity 状态。如果没有状态信息需要恢复，则传递给您的 Bundle 是空值（如果是首次创建该 Activity，就会出现这种情况）。 图 2. 在两种情况下，Activity 重获用户焦点时可保持状态完好：系统在销毁 Activity 后重建 Activity，Activity 必须恢复之前保存的状态；系统停止 Activity 后继续执行 Activity，并且 Activity 状态保持完好。 注：无法保证系统会在销毁您的 Activity 前调用 onSaveInstanceState()，因为存在不需要保存状态的情况（例如用户使用“返回”按钮离开您的 Activity 时，因为用户的行为是在显式关闭 Activity）。 如果系统调用 onSaveInstanceState()，它会在调用 onStop() 之前，并且可能会在调用onPause() 之前进行调用。 不过，即使您什么都不做，也不实现 onSaveInstanceState()，Activity 类的 onSaveInstanceState() 默认实现也会恢复部分 Activity 状态。具体地讲，默认实现会为布局中的每个 View 调用相应的 onSaveInstanceState() 方法，让每个视图都能提供有关自身的应保存信息。Android 框架中几乎每个小部件都会根据需要实现此方法，以便在重建 Activity 时自动保存和恢复对 UI 所做的任何可见更改。例如，EditText 小部件保存用户输入的任何文本，CheckBox 小部件保存复选框的选中或未选中状态。您只需为想要保存其状态的每个小部件提供一个唯一的 ID（通过 android:id 属性）。如果小部件没有 ID，则系统无法保存其状态。 您还可以通过将android:saveEnabled 属性设置为\"false\" 或通过调用setSaveEnabled() 方法显式阻止布局内的视图保存其状态。您通常不应将该属性停用，但如果您想以不同方式恢复 Activity UI 的状态，就可能需要这样做。 尽管 onSaveInstanceState() 的默认实现会保存有关您的Activity UI 的有用信息，您可能仍需替换它以保存更多信息。例如，您可能需要保存在 Activity 生命周期内发生了变化的成员值（它们可能与 UI 中恢复的值有关联，但默认情况下系统不会恢复储存这些 UI 值的成员）。 由于 onSaveInstanceState() 的默认实现有助于保存 UI 的状态，因此如果您为了保存更多状态信息而替换该方法，应始终先调用 onSaveInstanceState() 的超类实现，然后再执行任何操作。 同样，如果您替换onRestoreInstanceState() 方法，也应调用它的超类实现，以便默认实现能够恢复视图状态。 注：由于无法保证系统会调用 onSaveInstanceState()，因此您只应利用它来记录 Activity 的瞬态（UI 的状态）— 切勿使用它来存储持久性数据，而应使用 onPause() 在用户离开 Activity 后存储持久性数据（例如应保存到数据库的数据）。 您只需旋转设备，让屏幕方向发生变化，就能有效地测试您的应用的状态恢复能力。 当屏幕方向变化时，系统会销毁并重建 Activity，以便应用可供新屏幕配置使用的备用资源。 单凭这一理由，您的 Activity 在重建时能否完全恢复其状态就显得非常重要，因为用户在使用应用时经常需要旋转屏幕。 处理配置变更 有些设备配置可能会在运行时发生变化（例如屏幕方向、键盘可用性及语言）。 发生此类变化时，Android 会重建运行中的 Activity（系统调用onDestroy()，然后立即调用 onCreate()）。此行为旨在通过利用您提供的备用资源（例如适用于不同屏幕方向和屏幕尺寸的不同布局）自动重新加载您的应用来帮助它适应新配置。 如果您对 Activity 进行了适当设计，让它能够按以上所述处理屏幕方向变化带来的重启并恢复 Activity 状态，那么在遭遇 Activity 生命周期中的其他意外事件时，您的应用将具有更强的适应性。 正如上文所述，处理此类重启的最佳方法是利用onSaveInstanceState() 和 onRestoreInstanceState()（或 onCreate()）保存并恢复 Activity 的状态。 如需了解有关运行时发生的配置变更以及应对方法的详细信息，请阅读处理运行时变更指南。 协调 Activity 当一个 Activity 启动另一个 Activity 时，它们都会体验到生命周期转变。第一个 Activity 暂停并停止（但如果它在后台仍然可见，则不会停止）时，同时系统会创建另一个 Activity。 如果这些 Activity 共用保存到磁盘或其他地方的数据，必须了解的是，在创建第二个 Activity 前，第一个 Activity 不会完全停止。更确切地说，启动第二个 Activity 的过程与停止第一个 Activity 的过程存在重叠。 生命周期回调的顺序经过明确定义，当两个 Activity 位于同一进程，并且由一个 Activity 启动另一个 Activity 时，其定义尤其明确。 以下是当 Activity A 启动 Activity B 时一系列操作的发生顺序： Activity A 的 onPause() 方法执行。 Activity B 的 onCreate()、onStart() 和 onResume() 方法依次执行。（Activity B 现在具有用户焦点。） 然后，如果 Activity A 在屏幕上不再可见，则其 onStop() 方法执行。 您可以利用这种可预测的生命周期回调顺序管理从一个 Activity 到另一个 Activity 的信息转变。 例如，如果您必须在第一个 Activity 停止时向数据库写入数据，以便下一个 Activity 能够读取该数据，则应在 onPause() 而不是 onStop() 执行期间向数据库写入数据。 常用属性或场景 始终横屏 android:screenOrientation=\"portrait\" 始终横屏 android:screenOrientation=\"landscape\" android:screenOrientation: \"unspecified\" 默认值 由系统来判断显示方向.判定的策略是和设备相关的，所以不同的设备会有不同的显示方向. \"landscape\" 横屏显示（宽比高要长） \"portrait\" 竖屏显示(高比宽要长) \"user\" 用户当前首选的方向 \"behind\" 和该Activity下面的那个Activity的方向一致(在Activity堆栈中的) \"sensor\" 有物理的感应器来决定。如果用户旋转设备这屏幕会横竖屏切换。 \"nosensor\" 忽略物理感应器，这样就不会随着用户旋转设备而更改了 （ \"unspecified\"设置除外 ）。 旋转屏幕不重新创建Activity android:configChanges=\"keyboardHidden|orientation|screenSize\" 监听配置变更，比如横竖屏切换： Activity.onConfigurationChanged IntentFilter //默认启动Activity和Launcher图标 //data，type等属性可以提供给其他App用隐式启动的方法来打开你的App，开放你的App功能给其他App使用，比如打开网页，打开文件等，然后使用getIntent().getData()，获取意图，判断，解析，打开你支持的文件 允许其他应用启动您的 Activity 与其他应用交互 Uri webpage = Uri.parse(\"http://www.android.com\"); Intent webIntent = new Intent(Intent.ACTION_VIEW, webpage); 验证是否存在接收 Intent 的应用 尽管 Android 平台保证某些 Intent 可以分解为内置应用之一（比如，“电话”、“电子邮件”或“日历”应用），您应在调用 Intent 之前始终包含确认步骤。 注意：如果您调用了 Intent，但设备上没有可用于处理 Intent 的应用，您的应用将崩溃。 要确认是否存在可响应 Intent 的可用 Activity，请调用 queryIntentActivities() 来获取能够处理您的 Intent 的 Activity 列表。如果返回的 List 不为空，您可以安全地使用该 Intent。例如： PackageManager packageManager = getPackageManager(); List activities = packageManager.queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY); boolean isIntentSafe = activities.size() > 0; 如果 isIntentSafe 是 true，则至少有一个应用将响应该 Intent。 如果它是 false，则没有任何应用处理该 Intent。 显示应用选择器 图 2. 选择器对话框。 注意，当您通过将您的 Intent 传递至 startActivity() 而启动 Activity 时，有多个应用响应 Intent，用户可以选择默认使用哪个应用（通过选中对话框底部的复选框；见图 1）。当执行用户通常希望每次使用相同应用进行的操作时，比如当打开网页（用户可能只使用一个网络浏览器）或拍照（用户可能习惯使用一个相机）时，这非常有用。 但是，如果要执行的操作可由多个应用处理并且用户可能 习惯于每次选择不同的应用 — 比如“共享”操作， 用户有多个应用分享项目 — 您应明确显示选择器对话框， 如图 2 所示。选择器对话框 强制用户选择用于每次操作的 应用（用户不能对此操作选择默认的应用）。 要显示选择器，请使用 createChooser() 创建Intent 并将其传递给 startActivity()。例如： Intent intent = new Intent(Intent.ACTION_SEND); ... // Always use string resources for UI text. // This says something like \"Share this photo with\" String title = getResources().getString(R.string.chooser_title); // Create intent to show chooser Intent chooser = Intent.createChooser(intent, title); // Verify the intent will resolve to at least one activity if (intent.resolveActivity(getPackageManager()) != null) { startActivity(chooser); } 这将显示一个对话框，其中包含响应传递给 createChooser() 方法的 Intent 的应用列表，并且将提供的文本用作对话框标题。 "},"四大组件/Service.html":{"url":"四大组件/Service.html","title":"Service","keywords":"","body":"Service 关于Android Service真正的完全详解，你需要知道的一切 Android Service使用详解 Service是Android中实现程序后台运行的解决方案，非常适合用于去执行哪些不需要和用户交互而且还要求长期运行的任务。不能运行在一个独立的进程当中，而是依赖与创建服务时所在的应用程序进程。只能在后台运行，并且可以和其他组件进行交互。 Service可以在很多场合使用，比如播放多媒体的时候用户启动了其他Activity，此时要在后台继续播放；比如检测SD卡上文件的变化；比如在后台记录你的地理信息位置的改变等等，总之服务是藏在后台的。 服务不会自动开启线程，我们需要在服务的内部手动创建子线程，并在这里执行具体的任务。关于多线程的知识：可以参考另外一篇文章：Android多线程----异步消息处理机制之Handler详解 Service简单概述   Service是Android系统中的四大组件之一，主要有两个应用场景：后台运行和跨进程访问。Service可以在后台执行长时间运行操作而不提供用户界面，除非系统必须回收内存资源，否则系统不会停止或销毁服务。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC) 需要注意的是，Service是在主线程里执行操作的，可能会因为执行耗时操作而导致ANR Service可以分为以下三种形式： 启动 当应用组件通过调用 startService() 启动服务时，服务即处于“启动”状态。一旦启动，服务即可在后台无限期运行，即使启动服务的组件已被销毁也不受影响。 已启动的服务通常是执行单一操作，而且不会将结果返回给调用方 绑定 当应用组件通过调用 bindService() 绑定到服务时，服务即处于“绑定”状态。绑定服务提供了一个客户端-服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。多个组件可以同时绑定服务，服务只会在组件与其绑定时运行，一旦该服务与所有组件之间的绑定全部取消，系统便会销毁它 启动且绑定 服务既可以是启动服务，也允许绑定。此时需要同时实现以下回调方法：onStartCommand()和 onBind()。系统不会在所有客户端都取消绑定时销毁服务。为此，必须通过调用 stopSelf() 或 stopService() 显式停止服务 无论应用是处于启动状态还是绑定状态，或者处于启动且绑定状态，任何应用组件均可像使用 Activity 那样通过调用 Intent 来使用服务（即使此服务来自另一应用），也可以通过清单文件将服务声明为私有服务，阻止其他应用访问 要使用服务，必须继承Service类（或者Service类的现有子类），在子类中重写某些回调方法，以处理服务生命周期的某些关键方面并提供一种机制将组件绑定到服务 onStartCommand() 当组件通过调用 startService() 请求启动服务时，系统将调用此方法（如果是绑定服务则不会调用此方法）。一旦执行此方法，服务即会启动并可在后台无限期运行。 在指定任务完成后，通过调用 stopSelf() 或 stopService() 来停止服务 onBind() 当一个组件想通过调用 bindService() 与服务绑定时，系统将调用此方法（如果是启动服务则不会调用此方法）。在此方法的实现中，必须通过返回 IBinder 提供一个接口，供客户端用来与服务进行通信 onCreate() 首次创建服务时，系统将调用此方法来执行初始化操作（在调用 onStartCommand() 或 onBind() 之前）。如果在启动或绑定之前Service已在运行，则不会调用此方法 onDestroy() 当服务不再使用且将被销毁时，系统将调用此方法，这是服务接收的最后一个调用，在此方法中应清理占用的资源 仅当内存过低必须回收系统资源以供前台 Activity 使用时，系统才会强制停止服务。如果将服务绑定到前台 Activity，则它不太可能会终止，如果将服务声明为在前台运行，则它几乎永远不会终止。或者，如果服务已启动并要长时间运行，则系统会随着时间的推移降低服务在后台任务列表中的位置，而服务也将随之变得非常容易被终止。如果服务是启动服务，则必须将其设计为能够妥善处理系统对它的重启。 如果系统终止服务，那么一旦资源变得再次可用，系统便会重启服务（这还取决于 onStartCommand() 的返回值） Service在清单文件中的声明   前面说过Service分为启动状态和绑定状态两种，但无论哪种具体的Service启动类型，都是通过继承Service基类自定义而来，也都需要在AndroidManifest.xml中声明，那么在分析这两种状态之前，我们先来了解一下Service在AndroidManifest.xml中的声明语法，其格式如下： . . . android:exported：代表是否能被其他应用隐式调用，其默认值是由service中有无intent-filter决定的，如果有intent-filter，默认值为true，否则为false。为false的情况下，即使有intent-filter匹配，也无法打开，即无法被其他应用隐式调用。 android:name：对应Service类名 android:permission：是权限声明 android:process：是否需要在单独的进程中运行,当设置为android:process=”:remote”时，代表Service在单独的进程中运行。注意“：”很重要，它的意思是指要在当前进程名称前面附加上当前的包名，所以“remote”和”:remote”不是同一个意思，前者的进程名称为：remote，而后者的进程名称为：App-packageName:remote。 android:isolatedProcess ：设置 true 意味着，服务会在一个特殊的进程下运行，这个进程与系统其他进程分开且没有自己的权限。与其通信的唯一途径是通过服务的API(bind and start)。 android:enabled：是否可以被系统实例化，默认为 true因为父标签 也有 enable 属性，所以必须两个都为默认值 true 的情况下服务才会被激活，否则不会激活。 首先要创建服务，必须创建 Service 的子类（或使用它的一个现有子类如IntentService）。 Service绑定服务   绑定服务是Service的另一种变形，当Service处于绑定状态时，其代表着客户端-服务器接口中的服务器。当其他组件（如 Activity）绑定到服务时（有时我们可能需要从Activity组建中去调用Service中的方法，此时Activity以绑定的方式挂靠到Service后，我们就可以轻松地方法到Service中的指定方法），组件（如Activity）可以向Service（也就是服务端）发送请求，或者调用Service（服务端）的方法，此时被绑定的Service（服务端）会接收信息并响应，甚至可以通过绑定服务进行执行进程间通信 (即IPC，这个后面再单独分析)。与启动服务不同的是绑定服务的生命周期通常只在为其他应用组件(如Activity)服务时处于活动状态，不会无限期在后台运行，也就是说宿主(如Activity)解除绑定后，绑定服务就会被销毁。那么在提供绑定的服务时，该如何实现呢？实际上我们必须提供一个 IBinder接口的实现类，该类用以提供客户端用来与服务进行交互的编程接口，该接口可以通过三种方法定义接口： 扩展 Binder 类   如果服务是提供给自有应用专用的，并且Service(服务端)与客户端相同的进程中运行（常见情况），则应通过扩展 Binder 类并从 onBind() 返回它的一个实例来创建接口。客户端收到 Binder 后，可利用它直接访问 Binder 实现中以及Service 中可用的公共方法。如果我们的服务只是自有应用的后台工作线程，则优先采用这种方法。 不采用该方式创建接口的唯一原因是，服务被其他应用或不同的进程调用。 使用 Messenger   Messenger可以翻译为信使，通过它可以在不同的进程中共传递Message对象(Handler中的Messager，因此 Handler 是 Messenger 的基础)，在Message中可以存放我们需要传递的数据，然后在进程间传递。如果需要让接口跨不同的进程工作，则可使用 Messenger 为服务创建接口，客户端就可利用 Message 对象向服务发送命令。同时客户端也可定义自有 Messenger，以便服务回传消息。这是执行进程间通信 (IPC) 的最简单方法，因为 Messenger 会在单一线程中创建包含所有请求的队列，也就是说Messenger是以串行的方式处理客户端发来的消息，这样我们就不必对服务进行线程安全设计了。 使用 AIDL 由于Messenger是以串行的方式处理客户端发来的消息，如果当前有大量消息同时发送到Service(服务端)，Service仍然只能一个个处理，这也就是Messenger跨进程通信的缺点了，因此如果有大量并发请求，Messenger就会显得力不从心了，这时AIDL（Android 接口定义语言）就派上用场了， 但实际上Messenger 的跨进程方式其底层实现 就是AIDL，只不过android系统帮我们封装成透明的Messenger罢了 。因此，如果我们想让服务同时处理多个请求，则应该使用 AIDL。 在此情况下，服务必须具备多线程处理能力，并采用线程安全式设计。使用AIDL必须创建一个定义编程接口的 .aidl 文件。Android SDK 工具利用该文件生成一个实现接口并处理 IPC 的抽象类，随后可在服务内对其进行扩展。 以上3种实现方式，我们可以根据需求自由的选择，但需要注意的是大多数应用“都不会”使用 AIDL 来创建绑定服务，因为它可能要求具备多线程处理能力，并可能导致实现的复杂性增加。 管理服务的生命周期（从创建到销毁）有以下两种情况： 启动服务 该服务在其他组件调用 startService() 时创建，然后无限期运行，且必须通过调用 stopSelf() 来自行停止运行。此外，其他组件也可以通过调用 stopService() 来停止服务。服务停止后，系统会将其销毁。 绑定服务 该服务在另一个组件（客户端）调用 bindService() 时创建。然后，客户端通过 IBinder 接口与服务进行通信。客户端可以通过调用 unbindService() 关闭连接。多个客户端可以绑定到相同服务，而且当所有绑定全部取消后，系统即会销毁该服务。 （服务不必自行停止运行） IntentService Service服务是Android四大组件之一，在Android中有着举足重轻的作用。Service服务是工作的UI线程中，当你的应用需要下载一个文件或者播放音乐等长期处于后台工作而有没有UI界面的时候，你肯定要用到Service+Thread来实现。因此你需要自己在Service服务里面实现一个Thread工作线程来下载文件或者播放音乐。然而你每次都需要自己去写一个Service+Thread来处理长期处于后台而没有UI界面的任务，这样显得很麻烦，没必要每次都去构建一个Service+Thread框架处理长期处于后台的任务。Google工程师给我们构建了一个方便开发者使用的这么一个框架---IntentService。 IntentService是一个基础类，用于处理Intent类型的异步任务请求。当客户端调用android.content.Context#startService(Intent)发送请求时，Service服务被启动，且在其内部构建一个工作线程来处理Intent请求。当工作线程执行结束，Service服务会自动停止。IntentService是一个抽象类，用户必须实现一个子类去继承它，且必须实现IntentService里面的抽象方法onHandleIntent来处理异步任务请求。 IntentService总结 子类需继承IntentService并且实现里面的onHandlerIntent抽象方法来处理intent类型的任务请求。 子类需要重写默认的构造方法，且在构造方法中调用父类带参数的构造方法。 IntentService类内部利用HandlerThread+Handler构建了一个带有消息循环处理机制的后台工作线程，客户端只需调用Content#startService(Intent)将Intent任务请求放入后台工作队列中，且客户端无需关注服务是否结束，非常适合一次性的后台任务。比如浏览器下载文件，退出当前浏览器之后，下载任务依然存在后台，直到下载文件结束，服务自动销毁。 只要当前IntentService服务没有被销毁，客户端就可以同时投放多个Intent异步任务请求，IntentService服务端这边是顺序执行当前后台工作队列中的Intent请求的，也就是每一时刻只能执行一个Intent请求，直到该Intent处理结束才处理下一个Intent。因为IntentService类内部利用HandlerThread+Handler构建的是一个单线程来处理异步任务。 "},"四大组件/BroadcastReceiver.html":{"url":"四大组件/BroadcastReceiver.html","title":"BroadcastReceiver","keywords":"","body":"BroadcastReceiver 在 Android 系统中，广播（Broadcast）是在组件之间传播数据的一种机制，这些组件可以位于不同的进程中，起到进程间通信的作用 BroadcastReceiver 是对发送出来的 Broadcast 进行过滤、接受和响应的组件。首先将要发送的消息和用于过滤的信息（Action，Category）装入一个 Intent 对象，然后通过调用 Context.sendBroadcast() 、 sendOrderBroadcast() 方法把 Intent 对象以广播形式发送出去。 广播发送出去后，所以已注册的 BroadcastReceiver 会检查注册时的 IntentFilter 是否与发送的 Intent 相匹配，若匹配则会调用 BroadcastReceiver 的 onReceiver() 方法 所以当我们定义一个 BroadcastReceiver 的时候，都需要实现 onReceiver() 方法。BroadcastReceiver 的生命周期很短，在执行 onReceiver() 方法时才有效，一旦执行完毕，该Receiver 的生命周期就结束了 Android中的广播分为两种类型，标准广播和有序广播 标准广播 标准广播是一种完全异步执行的广播，在广播发出后所有的广播接收器会在同一时间接收到这条广播，之间没有先后顺序，效率比较高，且无法被截断 有序广播 有序广播是一种同步执行的广播，在广播发出后同一时刻只有一个广播接收器能够接收到， 优先级高的广播接收器会优先接收，当优先级高的广播接收器的 onReceiver() 方法运行结束后，广播才会继续传递，且前面的广播接收器可以选择截断广播，这样后面的广播接收器就无法接收到这条广播了 注册方法 静态注册 静态注册即在清单文件中为 BroadcastReceiver 进行注册，使用标签声明，并在标签内用 标签设置过滤器。这种形式的 BroadcastReceiver 的生命周期伴随着整个应用，如果这种方式处理的是系统广播，那么不管应用是否在运行，该广播接收器都能接收到该广播 动态注册 动态注册 BroadcastReceiver 是在代码中定义并设置好一个 IntentFilter 对象，然后在需要注册的地方调用 Context.registerReceiver() 方法，调用 Context.unregisterReceiver() 方法取消注册，此时就不需要在清单文件中注册 Receiver 了 本地广播LocalBroadcastManager 本地广播是无法通过静态注册的方式来接收的，因为静态注册广播主要是为了在程序未启动的情况下也能接收广播，而本地广播是应用自己发送的，此时应用肯定是启动的了 使用私有权限 使用动态注册广播接收器存在一个问题，即系统内的任何应用均可监听并触发我们的 Receiver 。通常情况下我们是不希望如此的 解决办法之一是在清单文件中为 标签添加一个 android:exported=\"false\" 属性，标明该 Receiver 仅限应用内部使用。这样，系统中的其他应用就无法接触到该 Receiver 了 "},"四大组件/ContentProvider.html":{"url":"四大组件/ContentProvider.html","title":"ContentProvider","keywords":"","body":"ContentProvider ContentProvider "},"基本组件/readme.html":{"url":"基本组件/readme.html","title":"基本组件","keywords":"","body":"基本组件 "},"基本组件/Application.html":{"url":"基本组件/Application.html","title":"Application","keywords":"","body":"Application 作用 onCreate 初始化全局资源 registerComponentCallbacks() & unregisterComponentCallbacks() 注册和注销 ComponentCallbacks2回调接口 registerComponentCallbacks(new ComponentCallbacks2() { // 接口里方法下面会继续介绍 @Override public void onTrimMemory(int level) { } @Override public void onLowMemory() { } @Override public void onConfigurationChanged(Configuration newConfig) { } }); onTrimMemory 通知 应用程序 当前内存使用情况（以内存级别进行识别） onLowMemory 监听 Android系统整体内存较低时刻 应用场景：Android 4.0前 检测内存使用情况，从而避免被系统直接杀掉 & 优化应用程序的性能体验 类似于 OnTrimMemory（） 特别注意：OnTrimMemory（） & OnLowMemory（） 关系 OnTrimMemory（）是 OnLowMemory（） Android 4.0后的替代 API OnLowMemory（） = OnTrimMemory（）中的TRIM_MEMORY_COMPLETE级别 若想兼容Android 4.0前，请使用OnLowMemory（）；否则直接使用OnTrimMemory（）即可 onConfigurationChanged 监听 应用程序 配置信息的改变，如屏幕旋转等 registerActivityLifecycleCallbacks（） & unregisterActivityLifecycleCallbacks（）注册 / 注销对 应用程序内 所有Activity的生命周期监听 onTerminate 应用程序结束时调用 但该方法只用于Android仿真机测试，在Android产品机是不会调用的 使用场景 初始化 应用程序级别 的资源，如全局对象、环境配置变量等 数据共享、数据缓存，如设置全局共享变量、方法等 获取应用程序当前的内存使用情况，及时释放资源，从而避免被系统杀死 监听 应用程序 配置信息的改变，如屏幕旋转等 监听应用程序内 所有Activity的生命周期 生命周期 public class App extends Application { @Override public void onCreate() { // 程序创建的时候执行 Log.d(TAG, \"onCreate\"); super.onCreate(); } @Override public void onTerminate() { // 程序终止的时候执行 Log.d(TAG, \"onTerminate\"); super.onTerminate(); } @Override public void onLowMemory() { // 低内存的时候执行 Log.d(TAG, \"onLowMemory\"); super.onLowMemory(); } @Override public void onTrimMemory(int level) { // 程序在内存清理的时候执行 Log.d(TAG, \"onTrimMemory\"); super.onTrimMemory(level); } @Override public void onConfigurationChanged(Configuration newConfig) { Log.d(TAG, \"onConfigurationChanged\"); super.onConfigurationChanged(newConfig); } } "},"基本组件/WebView.html":{"url":"基本组件/WebView.html","title":"WebView","keywords":"","body":"WebView WebView常用方法 void loadUrl(String url):加载网络链接 url boolean canGoBack():判断 WebView 当前是否可以返回上一页 goBack():回退到上一页 boolean canGoForward():判断 WebView 当前是否可以向前一页 goForward():回退到前一页 onPause():类似 Activity 生命周期，页面进入后台不可见状态 pauseTimers():该方法面向全局整个应用程序的webview，它会暂停所有webview的layout，parsing，JavaScript Timer。当程序进入后台时，该方法的调用可以降低CPU功耗。 onResume():在调用 onPause()后，可以调用该方法来恢复 WebView 的运行。 resumeTimers():恢复pauseTimers时的所有操作。(注：pauseTimers和resumeTimers 方法必须一起使用，否则再使用其它场景下的 WebView 会有问题) destroy():销毁 WebView clearHistory():清除当前 WebView 访问的历史记录。 clearCache(boolean includeDiskFiles):清空网页访问留下的缓存数据。需要注意的时，由于缓存是全局的，所以只要是WebView用到的缓存都会被清空，即便其他地方也会使用到。该方法接受一个参数，从命名即可看出作用。若设为false，则只清空内存里的资源缓存，而不清空磁盘里的。 reload():重新加载当前请求 setLayerType(int layerType, Paint paint):设置硬件加速、软件加速 removeAllViews():清除子view。 clearSslPreferences():清除ssl信息。 clearMatches():清除网页查找的高亮匹配字符。 removeJavascriptInterface(String interfaceName):删除interfaceName 对应的注入对象 addJavascriptInterface(Object object,String interfaceName):注入 java 对象。 setVerticalScrollBarEnabled(boolean verticalScrollBarEnabled):设置垂直方向滚动条。 setHorizontalScrollBarEnabled(boolean horizontalScrollBarEnabled):设置横向滚动条。 loadUrl(String url, Map additionalHttpHeaders):加载制定url并携带http header数据。 evaluateJavascript(String script, ValueCallback resultCallback):Api 19 之后可以采用此方法之行 Js。 stopLoading():停止 WebView 当前加载。 clearView():在Android 4.3及其以上系统这个api被丢弃了， 并且这个api大多数情况下会有bug，经常不能清除掉之前的渲染数据。官方建议通过loadUrl(\"about:blank\")来实现这个功能，阴雨需要重新加载一个页面自然时间会收到影响。 freeMemory():释放内存，不过貌似不好用。 clearFormData():清除自动完成填充的表单数据。需要注意的是，该方法仅仅清除当前表单域自动完成填充的表单数据，并不会清除WebView存储到本地的数据。 WebView优化方案 1.WebView 动态加载 WebView 动态加载。就是不在xml中写WebView，写一个layout，然后把WebView add进去。 WebView mWebView = new WebView(getApplicationgContext()); LinearLayout mll = findViewById(R.id.xxx); mll.addView(mWebView); 然后： protected void onDestroy() { super.onDestroy(); mWebView.removeAllViews(); mWebView.destroy() } 这里用的getApplicationContext()也是防止内存溢出，这种方法有一个问题。如果你需要在WebView中打开链接或者你打开的页面带有flash，获得你的WebView想弹出一个dialog，都会导致从ApplicationContext到ActivityContext的强制类型转换错误，从而导致你应用崩溃。这是因为在加载flash的时候，系统会首先把你的WebView作为父控件，然后在该控件上绘制flash，他想找一个Activity的Context来绘制他，但是你传入的是ApplicationContext。然后就崩溃了。。。 2.独立的web进程，与主进程隔开 这个方法被运用于类似qq，微信这样的超级app中，这也是解决任何webview内存问题屡试不爽的方法 对于封装的webactivity，在manifest.xml中设置 然后在关闭webactivity时销毁进程 @Overrideprotected void onDestroy() { super.onDestroy(); System.exit(0); } 关闭浏览器后便销毁整个进程，这样一般95%的情况下不会造成内存泄漏之类的问题，但这就涉及到android进程间通讯，比较不方便处理， 优劣参半，也是可选的一个方案. WebView释放 完整的代码如下： public void destroy() { if (mWebView != null) { // 如果先调用destroy()方法，则会命中if (isDestroyed()) return;这一行代码，需要先onDetachedFromWindow()，再 // destory() ViewParent parent = mWebView.getParent(); if (parent != null) { ((ViewGroup) parent).removeView(mWebView); } mWebView.stopLoading(); // 退出时调用此方法，移除绑定的服务，否则某些特定系统会报错 mWebView.getSettings().setJavaScriptEnabled(false); mWebView.clearHistory(); mWebView.clearView(); mWebView.removeAllViews(); try { mWebView.destroy(); } catch (Throwable ex) { } } } 更多文章 Android WebView 全面干货指南 其他解决方案 TBS腾讯浏览服务 Hybrid方案 "},"Intent.html":{"url":"Intent.html","title":"Intent","keywords":"","body":"Intent Intent是什么？ Intent一般作为参数来使用，协助完成 Android各个组件之间的通讯。 Intent主要包括7个属性：Action（动作）、Data（数据）、Category（类别）、Type（数据类型）、Component（组件）、Extra（扩展信息）、Flag（标志位）。其中最常用的是Action属性和Data属性。 表现形式： 启动Activity startActivity(intent); startActivityForResult(intent, requestCode); 启动Service startService(intent); 发送Broadcast sendBroadcast(intent); sendOrderedBroadcast(intent, sendOrderedBroadcast); Intent种类 显式Intent //最常用方法 Intent intent = new Intent(this, SecondActivity.class); startActivity(intent); //setClass 或者 setClassName Intent intent = new Intent(); intent.setClass(this, SecondActivity.class); //或者intent.setClassName(this, \"com.example.app.SecondActivity\"); //或者intent.setClassName(this.getPackageName(),\"com.example.app.SecondActivity\"); startActivity(intent); //setComponent Intent intent = new Intent(); intent.setComponent(new ComponentName(getPackageName(), SecondActivity.class)) startActivity(intent); 隐式Intent 隐式，不明确指定启动哪个Activity，而是设置Action、Data、Category，让系统来筛选出合适的Activity。筛选是根据所有的``来筛选。 //打电话 Uri uri = Uri.parse(\"tel:10010\"); Intent intent = new Intent(Intent.ACTION_DIAL, uri); startActivity(intent); //使用选择器 Intent sendIntent = new Intent(Intent.ACTION_SEND); Intent chooser = Intent.createChooser(sendIntent, title); // Verify the original intent will resolve to at least one activity if (sendIntent.resolveActivity(getPackageManager()) != null) { startActivity(chooser); } "},"Fragment.html":{"url":"Fragment.html","title":"Fragment","keywords":"","body":"Fragment 创建和使用 继承Fragment, 实现必要的方法，然后Activity加载Fragment。一般需要实现onCreateView, onViewCreated分别创建View，以及View创建完成之后数据的初始化。 使用方法： 通过Activity.getSupportFragmentManager 加载Fragment 布局中 标签直接声明 各类型Fragment DialogFragment 显示浮动对话框。使用此类创建对话框可有效地替代使用Activity 类中的对话框帮助程序方法，因为您可以将片段对话框纳入由 Activity 管理的片段返回栈，从而使用户能够返回清除的片段。 ListFragment 显示由适配器（如 SimpleCursorAdapter）管理的一系列项目，类似于 ListActivity。它提供了几种管理列表视图的方法，如用于处理点击事件的 onListItemClick() 回调。 PreferenceFragment 以列表形式显示 Preference 对象的层次结构，类似于 PreferenceActivity。这在为您的应用创建“设置” Activity 时很有用处。 FragmentManager和事务 要想管理您的 Activity 中的片段，您需要使用 FragmentManager。要想获取它，请从您的 Activity 调用getFragmentManager()。 您可以使用 FragmentManager 执行的操作包括： 通过 findFragmentById()（对于在 Activity 布局中提供 UI 的片段）或 findFragmentByTag()（对于提供或不提供 UI 的片段）获取 Activity 中存在的片段。 通过 popBackStack()（模拟用户发出的返回命令）将片段从返回栈中弹出。 通过 addOnBackStackChangedListener() 注册一个侦听返回栈变化的侦听器。 如需了解有关这些方法以及其他方法的详细信息，请参阅 FragmentManager 类文档。 如上文所示，您也可以使用 FragmentManager 打开一个 FragmentTransaction，通过它来执行某些事务，如添加和移除片段。 在 Activity 中使用片段的一大优点是，可以根据用户行为通过它们执行添加、移除、替换以及其他操作。 您提交给 Activity 的每组更改都称为事务，您可以使用 FragmentTransaction 中的 API 来执行一项事务。您也可以将每个事务保存到由 Activity 管理的返回栈内，从而让用户能够回退片段更改（类似于回退 Activity）。 您可以像下面这样从 FragmentManager 获取一个 FragmentTransaction 实例： FragmentManager fragmentManager = getFragmentManager(); FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); 每个事务都是您想要同时执行的一组更改。您可以使用 add()、remove() 和 replace() 等方法为给定事务设置您想要执行的所有更改。然后，要想将事务应用到 Activity，您必须调用 commit()。 不过，在您调用 commit() 之前，您可能想调用 addToBackStack()，以将事务添加到片段事务返回栈。 该返回栈由 Activity 管理，允许用户通过按返回按钮返回上一片段状态。 例如，以下示例说明了如何将一个片段替换成另一个片段，以及如何在返回栈中保留先前状态： // Create new fragment and transaction Fragment newFragment = new ExampleFragment(); FragmentTransaction transaction = getFragmentManager().beginTransaction(); // Replace whatever is in the fragment_container view with this fragment, // and add the transaction to the back stack transaction.replace(R.id.fragment_container, newFragment); transaction.addToBackStack(null); // Commit the transaction transaction.commit(); 在上例中，newFragment 会替换目前在 R.id.fragment_container ID 所标识的布局容器中的任何片段（如有）。通过调用 addToBackStack() 可将替换事务保存到返回栈，以便用户能够通过按返回按钮撤消事务并回退到上一片段。 如果您向事务添加了多个更改（如又一个 add() 或 remove()），并且调用了 addToBackStack()，则在调用commit() 前应用的所有更改都将作为单一事务添加到返回栈，并且返回按钮会将它们一并撤消。 向 FragmentTransaction 添加更改的顺序无关紧要，不过： 您必须最后调用 commit() 如果您要向同一容器添加多个片段，则您添加片段的顺序将决定它们在视图层次结构中的出现顺序 如果您没有在执行移除片段的事务时调用 addToBackStack()，则事务提交时该片段会被销毁，用户将无法回退到该片段。 不过，如果您在删除片段时调用了 addToBackStack()，则系统会停止该片段，并在用户回退时将其恢复。 "},"View.html":{"url":"View.html","title":"View","keywords":"","body":"View View是Android中所有控件的基类，不管是简单的TextView，Button还是复杂的LinearLayout和ListView，它们的共同基类都是View； View是一种界面层的控件的一种抽象，它代表了一个控件，除了View还有ViewGroup，从名字来看ViewGroup可以翻译为控件组，即一组View； 在Android中，ViewGroup也继承了View，这就意味着View可以是单个控件，也可以是由多个控件组成的一组控件； view提供的方法 getTop：获取到的，是view自身的顶边到其父布局顶边的距离 getLeft：获取到的，是view自身的左边到其父布局左边的距离 getRight：获取到的，是view自身的右边到其父布局左边的距离 getBottom：获取到的，是view自身的底边到其父布局顶边的距离 MotionEvent提供的方法 getX()：获取点击事件相对控件左边的x轴坐标，即点击事件距离控件左边的距离 getY()：获取点击事件相对控件顶边的y轴坐标，即点击事件距离控件顶边的距离 getRawX()：获取点击事件相对整个屏幕左边的x轴坐标，即点击事件距离整个屏幕左边的距离 getRawY()：获取点击事件相对整个屏幕顶边的y轴坐标，即点击事件距离整个屏幕顶边的距离 scrollTo是基于所传递参数的绝对移动，而scrollBy是基于当前位置的相对移动；就是To是我就移动到这个位置就不动了，By是基于我当前的位置继续偏移； ScrollTo和ScrollBy滑动的是view的显示内容，并不改变view的坐标 "},"动画.html":{"url":"动画.html","title":"动画","keywords":"","body":"动画 "},"五大存储.html":{"url":"五大存储.html","title":"五大存储","keywords":"","body":"五大存储 SharedPreference 适用范围：保存少量的数据，且这些数据的格式非常简单：字符串型、基本类型的值。比如应用程序的各种配置信息（如是否打开音效、是否使用震动效果、小游戏的玩家积分等），解锁口 令密码等 ​ 核心原理：保存基于XML文件存储的key-value键值对数据，通常用来存储一些简单的配置信息。通过DDMS的File Explorer面板，展开文件浏览树,很明显SharedPreferences数据总是存储在/data/data//shared_prefs目录下。SharedPreferences对象本身只能获取数据而不支持存储和修改,存储修改是通过SharedPreferences.edit()获取的内部接口Editor对象实现。 SharedPreferences本身是一 个接口，程序无法直接创建SharedPreferences实例，只能通过Context提供的getSharedPreferences(String name, int mode)方法来获取SharedPreferences实例，该方法中name表示要操作的xml文件名，第二个参数具体如下： ​ Context.MODE_PRIVATE: 指定该SharedPreferences数据只能被本应用程序读、写。 ​ Context.MODE_WORLD_READABLE: 指定该SharedPreferences数据能被其他应用程序读，但不能写。 ​ Context.MODE_WORLD_WRITEABLE: 指定该SharedPreferences数据能被其他应用程序读，写 Editor有如下主要重要方法： ​ SharedPreferences.Editor clear():清空SharedPreferences里所有数据 ​ SharedPreferences.Editor putXxx(String key , xxx value): 向SharedPreferences存入指定key对应的数据，其中xxx 可以是boolean,float,int等各种基本类型据 ​ SharedPreferences.Editor remove(): 删除SharedPreferences中指定key对应的数据项 ​ boolean commit(): 当Editor编辑完成后，使用该方法提交修改 SQLite数据库存储 嵌入式数据库，可通过SQLiteOpenHelper.getWriteableDatabase获取实例，然后进行增删改查操作 ContentProvider ContentProvider一般为存储和获取数据提供统一的接口，可以在不同的应用程序之间共享数据。 之所以使用ContentProvider，主要有以下几个理由： 1，ContentProvider提供了对底层数据存储方式的抽象。比如下图中，底层使用了SQLite数据库，在用了ContentProvider封装后，即使你把数据库换成MongoDB，也不会对上层数据使用层代码产生影响。 2，Android框架中的一些类需要ContentProvider类型数据。如果你想让你的数据可以使用在如SyncAdapter, Loader, CursorAdapter等类上，那么你就需要为你的数据做一层ContentProvider封装。 3，第三个原因也是最主要的原因，是ContentProvider为应用间的数据交互提供了一个安全的环境。它准许你把自己的应用数据根据需求开放给其他应用进行增、删、改、查，而不用担心直接开放数据库权限而带来的安全问题。 ContentProvider进行增，删，改，查的操作使用ContentResolver ContentResolver来统一管理与不同ContentProvider间的操作。 ContentProvider中的URI ContentProvider中的URI有固定格式： content://Authority/Path/Id URI Authority： 授权信息，用以区别不同的ContentProvider； Path： 表名，用以区分ContentProvider中不同的数据表； Id : 区分是哪一条数据 文件 context.getCacheDir() 存储应用私有缓存，当应用被卸载的时候，目录下的文件会被删除。 这个文件的目录和应用的存储位置有关， 当应用被移动到外部存储设备的时候，文件的绝对路径也是变化的，所以建议当数据存储到这个目录的时候，用相对路径。 这个目录和getFilesDir()目录最大的不同在于：当安卓设备的存储空间少，或者不够用的时候，系统会自动删除这个目录下的文件。官方建议是，超过1MB的文件，建议存储到getExternalCacheDir()目录下。 context.getExternalCacheDir() 存储应用私有缓存， 当应用被卸载的时候，目录下的文件会被删除。 只有手机系统使用的是虚拟外部存储（虚拟SD卡，现在绝大多数的手机，都不用外挂物理SD卡了）的时候， 才可以在卸载应用的同时，自动删除该目录下的文件，如果是之前的物理存储（物理SD卡）则不会自动删除该目录，及目录下的文件。 最好判断外部存储的挂载状态，结合context.getCacheDir()使用。 public String getDiskCacheDir( Context context) { String cachePath = null; if(Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState()) || !Environment .isExternalStorageRemovable()) { cachePath = context.getExternalCacheDir().getPath(); } else { cachePath = context.getCacheDir().getPath(); } return cachePath; } context.getFilesDir() 存储应用私有文件，当应用被卸载的时候，目录下的文件会被删除。这个文件的目录和应用的存储位置有关， 当应用被移动到外部存储设备的时候，文件的绝对路径也是变化的，所以建议当数据存储到这个目录的时候，用相对路径。系统提供的访问此路径文件的方法是：context.openFileOutput(String,int);context.openFileInput(String name)。 context.getExternalFilesDir(dirType) 存储应用私有文件，当应用被卸载的时候，目录下的文件会被删除。只有手机系统使用的是虚拟外部存储（虚拟SD卡）的时候， 才可以在卸载应用的同时，自动删除该目录下的文件，如果是之前的物理存储（物理SD卡）则不会自动删除该目录，及目录下的文件。 Environment.getExternalStorageDirectory() 应用外部存储空间，数据文件可被系统和用户访问，会被手机系统检索。 该目录下读写文件，需要获取读写权限。 这个目录是用户进行操作的一个根目录，进入二级目录可以通过getExternalFilesDirs(String), getExternalCacheDirs(), getExternalMediaDirs().这些方法。 官方建议，不要直接使用该目录，为了避免污染用户的根命名空间，应用私有的数据，应该放在 Context.getExternalFilesDir目录下 其他的可以被分享的文件，可以放在getExternalStoragePublicDirectory(String).目录下。 Environment.getExternalStoragePublicDirectory(dirType) 应用外部公共存储空间。用来存放各种类型的文件，Environment提供了各种directory类型。 Android 10收紧了权限，Environment.getExternalStorageDirectory()和Environment.getExternalStoragePublicDirectory(dirType)被标记为废弃，需要通过MediaStore适配文件访问。 网络 "},"优化/readme.html":{"url":"优化/readme.html","title":"优化","keywords":"","body":"优化 "},"优化/启动优化.html":{"url":"优化/启动优化.html","title":"启动优化","keywords":"","body":"启动优化 App启动是从点击打开App到首页启动起来的过程。冷启动消耗的时间最长，也是最有必要优化的。 App启动流程 参见好文 Launcher通过Binder进程间通信机制通知ActivityManagerService，它要启动一个Activity。 ActivityManagerService通过Binder进程间通信机制通知Launcher进入Paused状态。 Launcher通过Binder进程间通信机制通知ActivityManagerService，它已经准备就绪进入Paused状态， 于是ActivityManagerServicey利用Zygote.fork()创建一个新的进程，用来启动一个ActivityThread实例， 即将要启动的Activity就是在这个ActivityThread实例中运行。 ActivityThread通过Binder进程间通信机制将一个ApplicationThread类型的Binder对象传递给ActivityManagerService，以便以后ActivityManagerService能够通过这个Binder对象和它进行通信。 ActivityManagerService通过Binder进程间通信机制通知ActivityThread，现在一切准备就绪，它可以真正执行Activity的启动操作了。 ActivityThread.main() 初始化App环境 调用Looper.prepareMainLooper()创建当前线程的Looper，并且作为当前App主要的Looper。 创建ActivityThread，ActivityThread使用调用attachApplication()方法使用Binder机制向AMS传递了一个Application对象，AMS的接受到后调用相应的attachApplication()方法 attachApplication()调用attachApplicationLocked(), attachApplicationLocked()借助Binder通信IApplicationThread调用ApplicationThread.bindApplication(),其中sendMessage(H.BIND_APPLICATION, data)，然后在ActivityThread.H出接收消息，调用handleBindApplication(), LoadedApk.makeApplication()创建了Application实例，而后mInstrumentation.callApplicationOnCreate(app)，调用了Application.onCreate() public void callApplicationOnCreate(Application app) { app.onCreate(); } AMS得到了ActivityThread的Application对象后,又个给ActivityThread发送了一个消息，调用了ApplicationThread的performLaunchActivity()方法，performLaunchActivity() 借助Instrumentation，完成Activity创建，启动等流程。 创建Context：createBaseContextForActivity Instrumentation.newActivity Instrumentation.callActivityOnCreate public void callActivityOnCreate(Activity activity, Bundle icicle) { prePerformCreate(activity); //activity.performCreate调用了activity.onCreate，执行了生命周期方法 activity.performCreate(icicle); postPerformCreate(activity); } Looper开始消息轮询。 应用可以优化的地方有从Application.onCreate到默认Activity启动，减少耗时操作，优化启动流程。 加启动图防止白屏 （或默认Activity设置为透明） 默认Activity Theme设置为如下属性，windowBackground设置启动图，在Activity.onCreate中，setContentView之前，调用setTheme()，设置Theme为Activity可见之后的Theme。 true @drawable/launcher 优化Application.onCreate MultiDex优化。将启动时必需的方法，放在主Dex中等。部分问题及优化 减少onCreate中初始化第三方库等，或者不影响后续功能的情况下进行异步加载。 借助广告页，显示广告时间时间=广告页时间-启动时间 "},"优化/Apk瘦身.html":{"url":"优化/Apk瘦身.html","title":"Apk瘦身","keywords":"","body":"Apk瘦身 为什么apk体积增加？ 资源增加，尤其是适配多机型的图片 代码量增加 第三方库增加 使用了清晰度高的图片 多平台so库 瘦身方法 开启minifyEnable。它的作用不仅是混淆代码，还有压缩优化的功能，没有引用到的代码不会生成在apk中 慎重选择开源库，尽量避免使用体积大的开源库 开启shrinkResources功能，去除无用的resource文件，它需要配合minifyEnable使用，同样存在反射机制引用的问题，这种情况会被误删 defaultConfig中使用resConfigs剔除第三方库或者SDK中的资源 defaultConfig { 。。。 resConfigs \"zh\" //表示只使用中文 resConfigs \"xxhdpi\" // 表示只是用xxhdpi目录下的资源文件 } so库瘦身，去除不必要平台的so支持 defaultConfig { ndk { abiFilters \"armeabi-v7a\",\"x86\" } } 使用采用WebP，.9图，vector，xml等多种措施减少图片占用空间 "},"优化/电量优化.html":{"url":"优化/电量优化.html","title":"电量优化","keywords":"","body":"电量优化 手机哪些地方最耗电？ 唤醒屏幕 唤醒CPU 蜂窝式无线通信 定位功能 动态壁纸 推送亮屏 电量优化 JobScheduler，把一些不是特别紧急的任务放到更合适的时机批量处理，减少电量消耗 Gps不使用时要关闭服务，尽量重用上次保存的位置 "},"优化/布局优化.html":{"url":"优化/布局优化.html","title":"布局优化","keywords":"","body":"布局优化 减少层级，如Merge减少层级 ViewStub延迟View加载 减少过度绘制 绘制优化，View.onDraw避免执行耗时操作 不要创建新的局部对象。因为onDraw可能被频繁调用，瞬间产生大量临时对象 不做耗时操作，避免执行循环操作 "},"优化/性能优化.html":{"url":"优化/性能优化.html","title":"性能优化","keywords":"","body":"性能优化 主线程主要工作是更新UI，不要做耗时操作 图片加载优化，压缩，缓存网络图片 列表控件优化，比如RecyclerView采用增量刷新替代全量刷新 减少布局绘制层级 分析工具 As profiler Memory Analyzer Leak Canary 网络优化 后台限制或减少网络请求，比如借助JobScheduler进行任务调度 内存优化 内存分配 SparceArray，ArrayMap等Android提供的数据结构 内存泄漏 未关闭系统资源，比如registerReceiver, File等 WebView内存泄漏 匿名类：new AsyncTask, new Thread, TimerTask，这些匿名类对象结束前会持有Activity引用，导致无法回收，造成内存泄漏 混淆 //开启代码混淆 minifyEnabled true //Zipalign优化 zipAlignEnabled true //移除无用的resource文件 shrinkResources true 资源 defaultConfig { //只保留指定和默认的资源 resConfigs('zh-rCN','ko') } 动态库打包 ndk { //可以选择只保留需要的 abiFilters \"armeabi\", \"armeabi-v7a\" } apk瘦身 "},"适配/readme.html":{"url":"适配/readme.html","title":"适配","keywords":"","body":"适配 "},"适配/版本适配.html":{"url":"适配/版本适配.html","title":"版本适配","keywords":"","body":"版本适配 这里列举了部分需要开发中进行适配的功能变更 Android 6.0 运行时权限：用户可直接在运行时管理应用权限 Android 7.0 多窗口支持 FileProvider 功能适配 Android8.0 允许安装未知来源权限 public void onInstall(View view) { AndPermission.with(this) .runtime() .permission(Permission.Group.STORAGE) .onGranted(new Action>() { @Override public void onAction(List data) { installApp(); } }) .onDenied(new Action>() { @Override public void onAction(List data) { } }).start(); } private void installApp() { File file = new File(Environment.getExternalStorageDirectory(), \"0/1.apk\"); if(!file.exists()) { Toast.makeText(InstallAppActivity.this, \"文件不存在\", Toast.LENGTH_SHORT).show(); return; } if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) { boolean yes = getPackageManager().canRequestPackageInstalls(); if(!yes) { Uri packageURI = Uri.parse(\"package:\" + getPackageName()); Intent intent = new Intent(Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES, packageURI); startActivityForResult(intent, INSTALL_PERMISS_CODE); } else { realInstallApk(file); } } else { realInstallApk(file); } } private void realInstallApk(File file) { Intent intent = new Intent(Intent.ACTION_VIEW); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) { intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); String authority = getPackageName() + \".fileprovider\"; Uri contentUri = FileProvider .getUriForFile(getApplicationContext(), authority, file); intent.setDataAndType(contentUri, \"application/vnd.android.package-archive\"); } else { intent.setDataAndType(Uri.fromFile(file), \"application/vnd.android.package-archive\"); } startActivity(intent); } @Override protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) { if(resultCode == RESULT_OK && requestCode == INSTALL_PERMISS_CODE) { realInstallApk(new File(Environment.getExternalStorageDirectory(), \"0/1.apk\")); } super.onActivityResult(requestCode, resultCode, data); } "},"适配/UI适配.html":{"url":"适配/UI适配.html","title":"UI适配","keywords":"","body":"UI适配 屏幕尺寸 含义：手机对角线的物理尺寸 单位：英寸（inch），1英寸=2.54cm Android手机常见的尺寸有5寸、5.5寸、6寸等等 屏幕分辨率 含义：手机在横向、纵向上的像素点数总和 一般描述成屏幕的\"宽x高”=AxB 含义：屏幕在横向方向（宽度）上有A个像素点，在纵向方向 （高）有B个像素点 例子：1080x1920，即宽度方向上有1080个像素点，在高度方向上有1920个像素点 单位：px（pixel），1px=1像素点 UI设计师的设计图会以px作为统一的计量单位 Android手机常见的分辨率：320x480、480x800、720x1280、1080x1920 屏幕像素密度 含义：每英寸的像素点数 单位：dpi（dots per ich） 假设设备内每英寸有160个像素，那么该设备的屏幕像素密度=160dpi 安卓手机对于每类手机屏幕大小都有一个相应的屏幕像素密度： 密度类型 代表的分辨率（px） 屏幕像素密度（dpi） 低密度（ldpi） 240x320 120 中密度（mdpi） 320x480 160 高密度（hdpi） 480x800 240 超高密度（xhdpi） 720x1280 320 超超高密度（xxhdpi） 1080x1920 480 屏幕尺寸、分辨率、像素密度三者关系 一部手机的分辨率是宽x高，屏幕大小是以寸为单位，那么三者的关系是： ​ 三者关系示意图 密度无关像素 含义：density-independent pixel，叫dp或dip，与终端上的实际物理像素点无关。 单位：dp，可以保证在不同屏幕像素密度的设备上显示相同的效果 Android开发时用dp而不是px单位设置图片大小，是Android特有的单位 场景：假如同样都是画一条长度是屏幕一半的线，如果使用px作为计量单位，那么在480x800分辨率手机上设置应为240px；在320x480的手机上应设置为160px，二者设置就不同了；如果使用dp为单位，在这两种分辨率下，160dp都显示为屏幕一半的长度。 dp与px的转换 因为ui设计师给你的设计图是以px为单位的，Android开发则是使用dp作为单位的，那么我们需要进行转换： 密度类型 代表的分辨率（px） 屏幕密度（dpi） 换算（px/dp） 比例 低密度（ldpi） 240x320 120 1dp=0.75px 3 中密度（mdpi） 320x480 160 1dp=1px 4 高密度（hdpi） 480x800 240 1dp=1.5px 6 超高密度（xhdpi） 720x1280 320 1dp=2px 8 超超高密度（xxhdpi） 1080x1920 480 1dp=3px 12 在Android中，规定以160dpi（即屏幕分辨率为320x480）为基准：1dp=1px 独立比例像素 含义：scale-independent pixel，叫sp或sip 单位：sp Android开发时用此单位设置文字大小，可根据字体大小首选项进行缩放 推荐使用12sp、14sp、18sp、22sp作为字体设置的大小，不推荐使用奇数和小数，容易造成精度的丢失问题；小于12sp的字体会太小导致用户看不清 为什么要进行Android屏幕适配 由于Android系统的开放性，任何用户、开发者、OEM厂商、运营商都可以对Android进行定制，于是导致： Android系统碎片化：小米定制的MIUI、魅族定制的flyme、华为定制的EMUI等等 当然都是基于Google原生系统定制的 Android机型屏幕尺寸碎片化：5寸、5.5寸、6寸等等 Android屏幕分辨率碎片化：320x480、480x800、720x1280、1080x1920 据友盟指数显示，统计至2015年12月，支持Android的设备共有27796种 当Android系统、屏幕尺寸、屏幕密度出现碎片化的时候，就很容易出现同一元素在不同手机上显示不同的问题。 试想一下这么一个场景： 为4.3寸屏幕准备的UI设计图，运行在5.0寸的屏幕上，很可能在右侧和下侧存在大量的空白；而5.0寸的UI设计图运行到4.3寸的设备上，很可能显示不下。 为了保证用户获得一致的用户体验效果： 使得某一元素在Android不同尺寸、不同分辨率的手机上具备相同的显示效果 于是，我们便需要对Android屏幕进行适配。 屏幕适配问题的本质 使得“布局”、“布局组件”、“图片资源”、“用户界面流程”匹配不同的屏幕尺寸 使得布局、布局组件自适应屏幕尺寸； 根据屏幕的配置来加载相应的UI布局、用户界面流程 使得“图片资源”匹配不同的屏幕密度 适配类型和手段 布局适配 使用布局match_parent, wrap_content进行部分基本宽高适配 使用RelativeLayout相对定位 使用LinearLayout和ConstraintLayout进行布局宽高比适配，通过宽高比适配不同手机 图片适配 图片进行自适应宽高拉伸 提供不同尺寸手机的图片 .9.png 自动拉伸图片 尺寸适配 密度适配 layout-hdpi values-hdpi等 宽高限定适配 layout-1920x1080 values-1920x1080等 最小宽度适配 layout-sw360dp values-sw360dp 适配方案 dp适配 通过dp加上自适应布局和weight比例布局可以基本解决不同手机上适配的问题，这基本是最原始的Android适配方案。 这种方式存在两个小问题，第一，这只能保证我们写出来的界面适配绝大部分手机，部分手机仍然需要单独适配，为什么dp只解决了90%的适配问题，因为并不是所有的1080P的手机dpi都是480，比如Google 的Pixel2（19201080）的dpi是420，也就是说，在Pixel2中，1dp=2.625px,这样会导致相同分辨率的手机中，这样，一个100dp100dp的控件，在一般的1080P手机上，可能都是300px,而Pixel 2 中 ，就只有262.5px,这样控件的实际大小会有所不同。 为了更形象的展示，假设我们在布局文件中把一个ImageView的宽度设置为360dp,那么在下面两张图中表现是不一样的： 图一是1080P,480dpi的手机，图二是1080P,420dpi的手机 从上面的布局中可以看到，同样是1080P的手机，差异是比较明显的。在这种情况下，我们的UI可能需要做一些微调甚至单独适配。 第二个问题，这种方式无法快速高效的把设计师的设计稿实现到布局代码中，通过dp直接适配，我们只能让UI基本适配不同的手机,但是在设计图和UI代码之间的鸿沟，dp是无法解决的，因为dp不是真实像素。而且，设计稿的宽高往往和Android的手机真实宽高差别极大，以我们的设计稿为例，设计稿的宽高是375px750px，而真实手机可能普遍是10801920, 那么在日常开发中我们是怎么跨过这个鸿沟的呢？基本都是通过百分比啊，或者通过估算，或者设定一个规范值等等。总之，当我们拿到设计稿的时候，设计稿的ImageView是128px128px，当我们在编写layout文件的时候，却不能直接写成128dp128dp。在把设计稿向UI代码转换的过程中，我们需要耗费相当的精力去转换尺寸，这会极大的降低我们的生产力，拉低开发效率。 宽高限定符适配 宽高限定符适配，简单说，就是穷举市面上所有的Android手机的宽高像素值：values-480x320等 如果我们的UI设计界面使用的就是基准分辨率，那么我们就可以按照设计稿上的尺寸填写相对应的dimens引用了,而当APP运行在不同分辨率的手机中时，这些系统会根据这些dimens引用去该分辨率的文件夹下面寻找对应的值。这样基本解决了我们的适配问题，而且极大的提升了我们UI开发的效率， 但是这个方案有一个致命的缺陷，那就是需要精准命中才能适配，比如1920x1080的手机就一定要找到1920x1080的限定符，否则就只能用统一的默认的dimens文件了。而使用默认的尺寸的话，UI就很可能变形，简单说，就是容错机制很差。 smallestWidth适配（最小宽度适配） smallestWidth适配，或者叫sw限定符适配。指的是Android会识别屏幕可用高度和宽度的最小尺寸的dp值（其实就是手机的宽度值），然后根据识别到的结果去资源文件中寻找对应限定符的文件夹下的资源文件。 这种机制和上文提到的宽高限定符适配原理上是一样的，都是系统通过特定的规则来选择对应的文件。 举个例子，小米5的dpi是480,横向像素是1080px，根据px=dp(dpi/160)，横向的dp值是1080/(480/160),也就是360dp,系统就会去寻找是否存在value-sw360dp的文件夹以及对应的资源文件。 smallestWidth限定符适配和宽高限定符适配最大的区别在于，前者有很好的容错机制，如果没有value-sw360dp文件夹，系统会向下寻找，比如离360dp最近的只有value-sw350dp，那么Android就会选择value-sw350dp文件夹下面的资源文件。这个特性就完美的解决了上文提到的宽高限定符的容错问题。 这套方案是上述几种方案中最接近完美的方案。 首先，从开发效率上，它不逊色于上述任意一种方案。根据固定的放缩比例，我们基本可以按照UI设计的尺寸不假思索的填写对应的dimens引用。 我们还有以375个像素宽度的设计稿为例，在values-sw360dp文件夹下的diemns文件应该怎么编写呢？这个文件夹下，意味着手机的最小宽度的dp值是360，我们把360dp等分成375等份，每一个设计稿中的像素，大概代表smallestWidth值为360dp的手机中的0.96dp，那么接下来的事情就很简单了，假如设计稿上出现了一个10px*10px的ImageView,那么，我们就可以不假思索的在layout文件中写下对应的尺寸。 而这种diemns引用，在不同的values-swdp文件夹下的数值是不同的，比如values-sw360dp和values-sw400dp, 当系统识别到手机的smallestWidth值时，就会自动去寻找和目标数据最近的资源文件的尺寸。 其次，从稳定性上，它也优于上述方案。原生的dp适配可能会碰到Pixel 2这种有些特别的手机需要单独适配，但是在smallestWidth适配中，通过计算Pixel 2手机的的smallestWidth的值是411，我们只需要生成一个values-sw411dp(或者取整生成values-sw410dp也没问题)就能解决问题。 smallestWidth的适配机制由系统保证，我们只需要针对这套规则生成对应的资源文件即可，不会出现什么难以解决的问题，也根本不会影响我们的业务逻辑代码，而且只要我们生成的资源文件分布合理，，即使对应的smallestWidth值没有找到完全对应的资源文件，它也能向下兼容，寻找最接近的资源文件。 UI适配框架 AndroidAutoLayout 宽高限定符方案 AndroidAutoSize 今日头条适配方案 参考内容 Android 屏幕适配：最全面的解决方案 Android 目前最稳定和高效的UI适配方案 AndroidAutoSize "},"适配/系统和机型适配.html":{"url":"适配/系统和机型适配.html","title":"系统和机型适配","keywords":"","body":"系统和机型适配 "},"适配/暗黑模式.html":{"url":"适配/暗黑模式.html","title":"暗黑模式","keywords":"","body":"暗黑模式 主题继承Theme.AppCompat.DayNight或者它的子主题。 @color/colorPrimary @color/colorPrimaryDark @color/color_blue 在values-night，drawable-night，mipmap-night等目录提供夜间颜色，图片等 切换夜间/白天模式，调用之后会重新创建页面 //日间 切换 夜间 AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_NO) //夜间 切换 日间 AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_YES) MODE_NIGHT_FOLLOW_SYSTEM 模式：设置为跟随系统，通常为 MODE_NIGHT_NO 即日间模式 MODE_NIGHT_AUTO模式：自动模式，当我们的APP有网络及定位权限时。系统会根据当地的时间判断当前时处于白天还是黑夜，从而自动加载不同的模式 if((getResources().getConfiguration().uiMode & Configuration.UI_MODE_NIGHT_MASK) == Configuration.UI_MODE_NIGHT_YES) { //是黑夜模式 } "},"打包.html":{"url":"打包.html","title":"打包","keywords":"","body":"打包 Android Studio打包 Build-Generate signed apk 多渠道打包 渠道包就是要在安装包中添加渠道信息，也就是channel，对应不同的渠道，例如：小米市场、360市场、应用宝市场等，我们要在安装包中添加不同的标识，应用在请求网络的时候携带渠道信息，方便后台做运营统计。 //友盟多渠道打包配置 android { //解决错误，增加flavorDimensions：ERROR: All flavors must now belong to a named flavor dimension flavorDimensions \"a\" productFlavors { uc {} _360 {} baidu {} yyb {} } productFlavors.all { flavor -> flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name] } } //AndroidManifest.xml中增加： //自定义输出apk名字 applicationVariants.all { variant -> variant.outputs.all { output -> if (buildType.name == 'release') { outputFileName = new File(\"app_v\" + defaultConfig.versionName + \"_\" + new Date().format(\"yyyy-MM-dd\") + \"_\" + buildType.name + \".apk\") } } } 其他打包工具 AndroidMultiChannelBuildTool: Python多渠道打包工具 问题： 只支持v1签名 没法解决不同渠道使用渠道自己SDK的问题 Walle（瓦力）: Android Signature V2 Scheme签名下的新一代渠道包打包神器 瓦力通过在Apk中的APK Signature Block区块添加自定义的渠道信息来生成渠道包，从而提高了渠道包生成效率，可以作为单机工具来使用，也可以部署在HTTP服务器上来实时处理渠道包Apk的升级网络请求。 "},"国际化.html":{"url":"国际化.html","title":"国际化","keywords":"","body":"国际化 "},"加固和混淆/readme.html":{"url":"加固和混淆/readme.html","title":"加固和混淆","keywords":"","body":"加固和混淆 "},"加固和混淆/混淆.html":{"url":"加固和混淆/混淆.html","title":"混淆","keywords":"","body":"混淆 一、Android混淆最佳实践 1. 混淆配置 一般情况下，app module 的 build.gradle 文件默认会有如下结构： android { buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' } } } 因为开启混淆会使编译时间变长，所以debug模式下不应该开启。我们需要做的是： \\1. 将release下minifyEnabled的值改为true，打开混淆； \\2. 加上shrinkResources true，打开资源压缩。 修改后文件内容如下： android { buildTypes { release { minifyEnabled true shrinkResources true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' } } } 2. 自定义混淆规则 在 app module 下默认生成了项目的自定义混淆规则文件 proguard-rules.pro，多方调研后，一份适用于大部分项目的混淆规则最佳实践如下： #指定压缩级别 -optimizationpasses 5 #不跳过非公共的库的类成员 -dontskipnonpubliclibraryclassmembers #混淆时采用的算法 -optimizations !code/simplification/arithmetic,!field/*,!class/merging/* #把混淆类中的方法名也混淆了 -useuniqueclassmembernames #优化时允许访问并修改有修饰符的类和类的成员 -allowaccessmodification #将文件来源重命名为“SourceFile”字符串 -renamesourcefileattribute SourceFile #保留行号 -keepattributes SourceFile,LineNumberTable #保持所有实现 Serializable 接口的类成员 -keepclassmembers class * implements java.io.Serializable { static final long serialVersionUID; private static final java.io.ObjectStreamField[] serialPersistentFields; private void writeObject(java.io.ObjectOutputStream); private void readObject(java.io.ObjectInputStream); java.lang.Object writeReplace(); java.lang.Object readResolve(); } #Fragment不需要在AndroidManifest.xml中注册，需要额外保护下 -keep public class * extends android.support.v4.app.Fragment -keep public class * extends android.app.Fragment # 保持测试相关的代码 -dontnote junit.framework.** -dontnote junit.runner.** -dontwarn android.test.** -dontwarn android.support.test.** -dontwarn org.junit.** 真正通用的、需要添加的就是上面这些，除此之外，需要每个项目根据自身的需求添加一些混淆规则： - 第三方库所需的混淆规则。正规的第三方库一般都会在接入文档中写好所需混淆规则，使用时注意添加。 - 在运行时动态改变的代码，例如反射。比较典型的例子就是会与 json 相互转换的实体类。假如项目命名规范要求实体类都要放在model包下的话，可以添加类似这样的代码把所有实体类都保持住：-keep public class **.*Model*.** {*;} JNI中调用的类。 WebView中JavaScript调用的方法 Layout布局使用的View构造函数、android:onClick等。 3. 检查混淆结果 混淆过的包必须进行检查，避免因混淆引入的bug。 一方面，需要从代码层面检查。使用上文的配置进行混淆打包后在 /build/outputs/mapping/release/ 目录下会输出以下文件： dump.txt 描述APK文件中所有类的内部结构 mapping.txt 提供混淆前后类、方法、类成员等的对照表 seeds.txt 列出没有被混淆的类和成员 usage.txt 列出被移除的代码 我们可以根据 seeds.txt 文件检查未被混淆的类和成员中是否已包含所有期望保留的，再根据 usage.txt 文件查看是否有被误移除的代码。 另一方面，需要从测试方面检查。将混淆过的包进行全方面测试，检查是否有 bug 产生。 4. 解出混淆栈 混淆后的类、方法名等等难以阅读，这固然会增加逆向工程的难度，但对追踪线上 crash 也造成了阻碍。我们拿到 crash 的堆栈信息后会发现很难定位，这时需要将混淆反解。 在 /tools/proguard/ 路径下有附带的的反解工具（Window 系统为 proguardgui.bat，Mac 或 Linux 系统为 proguardgui.sh）。 这里以 Window 平台为例。双击运行 proguardgui.bat 后，可以看到左侧的一行菜单。点击 ReTrace，选择该混淆包对应的 mapping 文件（混淆后在 /build/outputs/mapping/release/ 路径下会生成 mapping.txt 文件，它的作用是提供混淆前后类、方法、类成员等的对照表），再将 crash 的 stack trace 黏贴进输入框中，点击右下角的 ReTrace ，混淆后的堆栈信息就显示出来了。 以上使用 GUI 程序进行操作，另一种方式是利用该路径下的 retrace 工具通过命令行进行反解，命令是 retrace.bat|retrace.sh [-verbose] mapping.txt [] 例如： retrace.bat -verbose mapping.txt obfuscated_trace.txt 注意事项： 1) 所有在 AndroidManifest.xml 涉及到的类已经自动被保持，因此不用特意去添加这块混淆规则。（很多老的混淆文件里会加，现在已经没必要） 2) proguard-android.txt 已经存在一些默认混淆规则，没必要在 proguard-rules.pro 重复添加，该文件具体规则见附录1： 二、混淆简介 Android中的“混淆”可以分为两部分，一部分是 Java 代码的优化与混淆，依靠 proguard 混淆器来实现；另一部分是资源压缩，将移除项目及依赖的库中未被使用的资源(资源压缩严格意义上跟混淆没啥关系，但一般我们都会放一起讲)。 1. 代码压缩 代码混淆是包含了代码压缩、优化、混淆等一系列行为的过程。如上图所示，混淆过程会有如下几个功能： \\1. 压缩。移除无效的类、类成员、方法、属性等； \\2. 优化。分析和优化方法的二进制代码；根据proguard-android-optimize.txt中的描述，优化可能会造成一些潜在风险，不能保证在所有版本的Dalvik上都正常运行。 \\3. 混淆。把类名、属性名、方法名替换为简短且无意义的名称； \\4. 预校验。添加预校验信息。这个预校验是作用在Java平台上的，Android平台上不需要这项功能，去掉之后还可以加快混淆速度。 这四个流程默认开启。 在 Android 项目中我们可以选择将“优化”和“预校验”关闭，对应命令是-dontoptimize、-dontpreverify（当然，默认的 proguard-android.txt 文件已包含这两条混淆命令，不需要开发者额外配置）。 2. 资源压缩 资源压缩将移除项目及依赖的库中未被使用的资源，这在减少 apk 包体积上会有不错的效果，一般建议开启。具体做法是在 build.grade 文件中，将 shrinkResources 属性设置为 true。需要注意的是，只有在用minifyEnabled true开启了代码压缩后，资源压缩才会生效。 资源压缩包含了“合并资源”和“移除资源”两个流程。 “合并资源”流程中，名称相同的资源被视为重复资源会被合并。需要注意的是，这一流程不受shrinkResources属性控制，也无法被禁止， gradle 必然会做这项工作，因为假如不同项目中存在相同名称的资源将导致错误。gradle 在四处地方寻找重复资源： src/main/res/ 路径 - 不同的构建类型（debug、release等等） - 不同的构建渠道 - 项目依赖的第三方库 合并资源时按照如下优先级顺序： 依赖 -> main -> 渠道 -> 构建类型 举个例子，假如重复资源同时存在于main文件夹和不同渠道中，gradle 会选择保留渠道中的资源。 同时，如果重复资源在同一层次出现，比如src/main/res/ 和 src/main/res2/，则 gradle 无法完成资源合并，这时会报资源合并错误。 “移除资源”流程则见名知意，需要注意的是，类似代码，混淆资源移除也可以定义哪些资源需要被保留，这点在下文给出。 三、自定义混淆规则 在上文“混淆配置”中有这样一行代码 proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' 这行代码定义了混淆规则由两部分构成：位于 SDK 的 tools/proguard/ 文件夹中的 proguard-android.txt 的内容以及默认放置于模块根目录的 proguard-rules.pro 的内容。前者是 SDK 提供的默认混淆文件（内容见附录1），后者是开发者自定义混淆规则的地方。 1. 常见混淆命令： optimizationpasses dontoptimize dontusemixedcaseclassnames dontskipnonpubliclibraryclasses dontpreverify dontwarn verbose optimizations keep keepnames keepclassmembers keepclassmembernames keepclasseswithmembers keepclasseswithmembernames 在第一部分 Android 混淆最佳实践中已介绍部分需要使用到的混淆命令，这里不再赘述，详情请查阅官网。需要特别介绍的是与保持相关元素不参与混淆的规则相关的几种命令： 命令 作用 -keep 防止类和成员被移除或者被重命名 -keepnames 防止类和成员被重命名 -keepclassmembers 防止成员被移除或者被重命名 -keepnames 防止成员被重命名 -keepclasseswithmembers 防止拥有该成员的类和成员被移除或者被重命名 -keepclasseswithmembernames 防止拥有该成员的类和成员被重命名 2. 保持元素不参与混淆的规则 形如： [保持命令] [类] { [成员] } “类”代表类相关的限定条件，它将最终定位到某些符合该限定条件的类。它的内容可以使用： - 具体的类 - 访问修饰符（public、protected、private） - 通配符*，匹配任意长度字符，但不含包名分隔符(.) - 通配符**，匹配任意长度字符，并且包含包名分隔符(.) extends，即可以指定类的基类 implement，匹配实现了某接口的类 - $，内部类 “成员”代表类成员相关的限定条件，它将最终定位到某些符合该限定条件的类成员。它的内容可以使用： - 匹配所有构造器 - 匹配所有域 - 匹配所有方法 - 通配符*，匹配任意长度字符，但不含包名分隔符(.) - 通配符**，匹配任意长度字符，并且包含包名分隔符(.) - 通配符***，匹配任意参数类型 …，匹配任意长度的任意类型参数。比如void test(…)就能匹配任意 void test(String a) 或者是 void test(int a, String b)这些方法。 - 访问修饰符（public、protected、private） 举个例子，假如需要将name.huihui.test包下所有继承Activity的public类及其构造函数都保持住，可以这样写： -keep public class name.huihui.test.** extends Android.app.Activity { } 3. 常用的自定义混淆规则 不混淆某个类 -keep public class name.huihui.example.Test { *; } 不混淆某个包所有的类 -keep class name.huihui.test.** { *; } 不混淆某个类的子类 -keep public class * extends name.huihui.example.Test { *; } 不混淆所有类名中包含了“model”的类及其成员 -keep public class **.*model*.** {*;} 不混淆某个接口的实现 -keep class * implements name.huihui.example.TestInterface { *; } 不混淆某个类的构造方法 -keepclassmembers class name.huihui.example.Test { public (); } 不混淆某个类的特定的方法 -keepclassmembers class name.huihui.example.Test { public void test(java.lang.String); } 四、自定义资源保持规则 1. keep.xml 用shrinkResources true开启资源压缩后，所有未被使用的资源默认被移除。假如你需要定义哪些资源必须被保留，在 res/raw/路径下创建一个 xml 文件，例如 keep.xml。 通过一些属性的设置可以实现定义资源保持的需求，可配置的属性有： tools:keep 定义哪些资源需要被保留（资源之间用“,”隔开） tools:discard 定义哪些资源需要被移除（资源之间用“,”隔开） tools:shrinkMode 开启严格模式 当代码中通过 Resources.getIdentifier() 用动态的字符串来获取并使用资源时，普通的资源引用检查就可能会有问题。例如，如下代码会导致所有以“img_”开头的资源都被标记为已使用。 String name = String.format(\"img_%1d\", angle + 1); res = getResources().getIdentifier(name, \"drawable\", getPackageName()); 我们可以设置 tools:shrinkMode 为 strict 来开启严格模式，使只有确实被使用的资源被保留。 以上就是自定义资源保持规则相关的配置，举个例子： 2. 移除替代资源 一些替代资源，例如多语言支持的 strings.xml，多分辨率支持的 layout.xml 等，在我们不需要使用又不想删除掉时，可以使用资源压缩将它们移除。 我们使用 resConfig 属性来指定需要支持的属性，例如 android { defaultConfig { ... resConfigs \"en\", \"fr\" } } 其他未显式声明的语言资源将被移除。 附录 proguard-android.txt文件内容 #包名不混合大小写 -dontusemixedcaseclassnames #不跳过非公共的库的类 -dontskipnonpubliclibraryclasses #混淆时记录日志 -verbose #关闭预校验 -dontpreverify #不优化输入的类文件 -dontoptimize #保护注解 -keepattributes *Annotation* #保持所有拥有本地方法的类名及本地方法名 -keepclasseswithmembernames class * { native ; } #保持自定义View的get和set相关方法 -keepclassmembers public class * extends android.view.View { void set*(***); *** get*(); } #保持Activity中View及其子类入参的方法 -keepclassmembers class * extends android.app.Activity { public void *(android.view.View); } #枚举 -keepclassmembers enum * { **[] $VALUES; public *; } #Parcelable -keepclassmembers class * implements android.os.Parcelable { public static final android.os.Parcelable$Creator CREATOR; } #R文件的静态成员 -keepclassmembers class **.R$* { public static ; } -dontwarn android.support.** #keep相关注解 -keep class android.support.annotation.Keep -keep @android.support.annotation.Keep class * {*;} -keepclasseswithmembers class * { @android.support.annotation.Keep ; } -keepclasseswithmembers class * { @android.support.annotation.Keep ; } -keepclasseswithmembers class * { @android.support.annotation.Keep (...); } 本文引用自 写给 Android 开发者的混淆使用手册，因个人水平所限，以及混淆相关的文章已经非常多，没有必要完全重新写新篇，直接选了典型的文章进行了总结整理，感谢作者的文章 参考资料 Android安全攻防战，反编译与混淆技术完全解析（上） Android安全攻防战，反编译与混淆技术完全解析（下） Android 高级混淆和代码保护技术 原文参考资料 Shrink Your Code and Resources proguard Android安全攻防战，反编译与混淆技术完全解析（下） Android混淆从入门到精通 Android代码混淆之ProGuard "},"加固和混淆/加固.html":{"url":"加固和混淆/加固.html","title":"加固","keywords":"","body":"加固 "},"混合开发.html":{"url":"混合开发.html","title":"混合开发","keywords":"","body":"混合开发 "},"组件化.html":{"url":"组件化.html","title":"组件化","keywords":"","body":"组件化 模块化编程是将程序按照功能拆分成相互独立的若干模块，强调程序的功能分离成独立的、可替换的模块，每个模块内只有与其相关功能的内容。 组件化开发是软件工程的一个分支，强调给定软件系统中广泛可用的功能进行分割，基于可重用的目的讲一个大的软件系统拆分成多个独立的组件，减少系统耦合度。 模块化 or 组件化 组件和模块大致定义： 组件：侧重业务，可变异成单独的App，一般只负责单一业务，具备自身的生命周期（通常包含Android四大组件中的若干个） 模块：侧重功能，与业务无关，比如自定义控件、网络请求库、图片加载库等。 建议App采用模块化开发，和业务无关的封装成组件，业务按照功能分成多模块，进行模块化开发。比如： App 业务1 业务2 common common集成公共模块，业务模块依赖common，App依赖各个业务。模块化的Activity相互调用问题采用Arouter等方案解决。其他组件一般不需要跨模块调用，因为是基于业务或者页面的，需要跨模块调用可能是放错了模块了。 "},"插件化.html":{"url":"插件化.html","title":"插件化","keywords":"","body":"插件化 组件化开发就是将一个app分成多个模块，每个模块都是一个组件（Module），开发的过程中我们可以让这些组件相互依赖或者单独调试部分组件等，但是最终发布的时候是将这些组件合并统一成一个apk，这就是组件化开发。 插件化架构下，每个业务模块都是一个独立可运行的APP，插件化顾名思义，更多是想把需要实现的模块或功能当做一个独立的提取出来，减少宿主的规模，当需要使用到相应的功能时再去加载相应的模块。 优点： 1.宿主与插件分开编译，互不影响 2.插件可独立运行，充分解耦 3.按需加载插件模块，减少宿主体积 4.动态更新插件模块 5.发版灵活：不用上架，不需用户主动更新 "},"热修复.html":{"url":"热修复.html","title":"热修复","keywords":"","body":"热修复 参考Android 插件化和热修复知识梳理 插件化和热修复不是同一个概念，虽然站在技术实现的角度来说，他们都是从系统加载器的角度出发，无论是采用hook方式，亦或是代理方式或者是其他底层实现，都是通过“欺骗”Android 系统的方式来让宿主正常的加载和运行插件（补丁）中的内容；但是二者的出发点是不同的。插件化顾名思义，更多是想把需要实现的模块或功能当做一个独立的提取出来，减少宿主的规模，当需要使用到相应的功能时再去加载相应的模块。热修复则往往是从修复bug的角度出发，强调的是在不需要二次安装应用的前提下修复已知的bug。 类加载机制 Android中类的加载也是通过ClassLoader来完成，具体来说就是PathClassLoader 和 DexClassLoader 这两个Android专用的类加载器。 PathClassLoader：只能加载已经安装到Android系统中的apk文件（/data/app目录），是Android默认使用的类加载器。 DexClassLoader：可以加载任意目录下的dex/jar/apk/zip文件，也就是我们一开始提到的补丁。 这两个类都是继承自BaseDexClassLoader，我们可以看一下BaseDexClassLoader的构造函数。 public BaseDexClassLoader(String dexPath, File optimizedDirectory, String libraryPath, ClassLoader parent) { super(parent); this.pathList = new DexPathList(this, dexPath, libraryPath, optimizedDirectory); } 这个构造函数只做了一件事，就是通过传递进来的相关参数，初始化了一个DexPathList对象。DexPathList的构造函数，就是将参数中传递进来的程序文件（就是补丁文件）封装成Element对象，并将这些对象添加到一个Element的数组集合dexElements中去。 ClassLoaer 的加载机制是一种特别聪明的方式，双亲委托机制，在这种机制下，一个Class只会被加载一次。 总的来说，通过DexClassLoader查找一个类，最终就是就是在一个数组中查找特定值的操作。 综合以上所有的观点，我们很容易想到一种非常简单粗暴的热修复方案。假设现在代码中的某一个类或者是某几个类有bug，那么我们可以在修复完bug之后，可以将这些个类打包成一个补丁文件，然后通过这个补丁文件封装出一个Element对象，并且将这个Element对象插到原有dexElements数组的最前端，这样当DexClassLoader去加载类时，优先会从我们插入的这个Element中找到相应的类，虽然那个有bug的类还存在于数组中后面的Element中，但由于双亲加载机制的特点，这个有bug的类已经没有机会被加载了，这样一个bug就在没有重新安装应用的情况下修复了。 热修复框架和方案 QQ 空间超级补丁方案 Tinker 策略有所不同，但总的来说都是从上层ClassLoader的角度出发，由于ClassLoader的特点，如果想要新的补丁文件再次生效，无论你是插桩还是提前合并，都需要重新启动应用来加载新的DexPathList。这样就无法在用户神不知鬼不觉的情况下把bug修复了，HotFix在这方面就有绝对的优势了。 HotFix(即AndFix) AndFix 提供了一种运行时在Native修改Filed指针的方式，实现方法的替换，达到即时生效无需重启，对应用无性能消耗的目的。 由于他是Native层操作，因此如果我们在Java层中新增字段，或者是修改类的方法，他是无能为力的。同时由于Android在国内变成了安卓，各大手机厂商定制了自己的ROM，所以很多底层实现的差异，导致AndFix的兼容性并不是很好。 Sophix 采用全量替换的思路，从一种更高的层次实现了热修复。应该是现有最成熟的热修复方案了。 "},"服务和机制.html":{"url":"服务和机制.html","title":"服务和机制","keywords":"","body":"服务和机制 "},"源码分析/readme.html":{"url":"源码分析/readme.html","title":"源码分析","keywords":"","body":"源码分析 "},"源码分析/handler.html":{"url":"源码分析/handler.html","title":"Handler","keywords":"","body":"Handler 0. 前言 做 Android 开发肯定离不开跟 Handler 打交道，它通常被我们用来做主线程与子线程之间的通信工具，而 Handler 作为 Android 中消息机制的重要一员也确实给我们的开发带来了极大的便利。 可以说只要有异步线程与主线程通信的地方就一定会有 Handler。 那么，Handler 的通信机制的背后的原理是什么？ 本文带你揭晓。 注意：本文所展示的系统源码基于 Android-27 ，并有所删减。 1. 重识 Handler 我们可以使用 Handler 发送并处理与一个线程关联的 Message 和 Runnable 。（注意：Runnable 会被封装进一个 Message，所以它本质上还是一个 Message ） 每个 Handler 都会跟一个线程绑定，并与该线程的 MessageQueue 关联在一起，从而实现消息的管理以及线程间通信。 1.1 Handler 的基本用法 android.os.Handler handler = new Handler(){ @Override public void handleMessage(final Message msg) { //这里接受并处理消息 } }; //发送消息 handler.sendMessage(message); handler.post(runnable); 复制代码 实例化一个 Handler 重写 handleMessage 方法 ，然后在需要的时候调用它的 send 以及 post 系列方法就可以了，非常简单易用，并且支持延时消息。（更多方法可查询 API 文档） 但是奇怪，我们并没有看到任何 MessageQueue 的身影，也没看到它与线程绑定的逻辑，这是怎么回事？ 2. Handler 原理解析 相信大家早就听说过了 Looper 以及 MessageQueue 了，我就不多绕弯子了。 不过在开始分析原理之前，先明确我们的问题： Handler 是如何与线程关联的？ Handler 发出去的消息是谁管理的？ 消息又是怎么回到 handleMessage() 方法的？ 线程的切换是怎么回事？ 2.1 Handler 与 Looper 的关联 实际上我们在实例化 Handler 的时候 Handler 会去检查当前线程的 Looper 是否存在，如果不存在则会报异常，也就是说在创建 Handler 之前一定需要先创建 Looper 。 代码如下： public Handler(Callback callback, boolean async) { //检查当前的线程是否有 Looper mLooper = Looper.myLooper(); if (mLooper == null) { throw new RuntimeException( \"Can't create handler inside thread that has not called Looper.prepare()\"); } //Looper 持有一个 MessageQueue mQueue = mLooper.mQueue; } 复制代码 这个异常相信很多同学遇到过，而我们平时直接使用感受不到这个异常是因为主线程已经为我们创建好了 Looper，先记住，后面会讲。（见【3.2】） 一个完整的 Handler 使用例子其实是这样的： class LooperThread extends Thread { public Handler mHandler; public void run() { Looper.prepare(); mHandler = new Handler() { public void handleMessage(Message msg) { // process incoming messages here } }; Looper.loop(); } } 复制代码 Looper.prepare() : //Looper private static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { throw new RuntimeException(\"Only one Looper may be created per thread\"); } sThreadLocal.set(new Looper(quitAllowed)); } 复制代码 Looper 提供了 Looper.prepare() 方法来创建 Looper ，并且会借助 ThreadLocal 来实现与当前线程的绑定功能。Looper.loop() 则会开始不断尝试从 MessageQueue 中获取 Message , 并分发给对应的 Handler（见【2.3】）。 也就是说 Handler 跟线程的关联是靠 Looper 来实现的。 2.2 Message 的存储与管理 Handler 提供了一些列的方法让我们来发送消息，如 send()系列 post()系列 。 不过不管我们调用什么方法，最终都会走到 MessageQueue.enqueueMessage(Message,long) 方法。 以 sendEmptyMessage(int) 方法为例： //Handler sendEmptyMessage(int) -> sendEmptyMessageDelayed(int,int) -> sendMessageAtTime(Message,long) -> enqueueMessage(MessageQueue,Message,long) -> queue.enqueueMessage(Message, long); 复制代码 到了这里，消息的管理者 MessageQueue 也就露出了水面。 MessageQueue 顾明思议，就是个队列，负责消息的入队出队。 2.3 Message 的分发与处理 了解清楚 Message 的发送与存储管理后，就该揭开分发与处理的面纱了。 前面说到了 Looper.loop() 负责对消息的分发，本章节进行分析。 先来看看所涉及到的方法： //Looper public static void loop() { final Looper me = myLooper(); if (me == null) { throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); } final MessageQueue queue = me.mQueue; //... for (;;) { // 不断从 MessageQueue 获取 消息 Message msg = queue.next(); // might block //退出 Looper if (msg == null) { // No message indicates that the message queue is quitting. return; } //... try { msg.target.dispatchMessage(msg); end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis(); } finally { //... } //... //回收 message, 见【3.5】 msg.recycleUnchecked(); } } 复制代码 loop() 里调用了 MessageQueue.next() : //MessageQueue Message next() { //... for (;;) { //... nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) { // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; //... if (msg != null) { if (now 还调用了 msg.target.dispatchMessage(msg) ，msg.target 就是发送该消息的 Handler，这样就回调到了 Handler 那边去了: //Handler public void dispatchMessage(Message msg) { //msg.callback 是 Runnable ，如果是 post方法则会走这个 if if (msg.callback != null) { handleCallback(msg); } else { //callback 见【3.4】 if (mCallback != null) { if (mCallback.handleMessage(msg)) { return; } } //回调到 Handler 的 handleMessage 方法 handleMessage(msg); } } 复制代码 注意：dispatchMessage() 方法针对 Runnable 的方法做了特殊处理，如果是 ，则会直接执行 Runnable.run() 。 分析：Looper.loop() 是个死循环，会不断调用 MessageQueue.next() 获取 Message ，并调用 msg.target.dispatchMessage(msg) 回到了 Handler 来分发消息，以此来完成消息的回调。 注意：loop()方法并不会卡死主线程，见【6】。 那么线程的切换又是怎么回事呢？ 很多人搞不懂这个原理，但是其实非常简单，我们将所涉及的方法调用栈画出来，如下： Thread.foo(){ Looper.loop() -> MessageQueue.next() -> Message.target.dispatchMessage() -> Handler.handleMessage() } 复制代码 显而易见，Handler.handleMessage() 所在的线程最终由调用 Looper.loop() 的线程所决定。 平时我们用的时候从异步线程发送消息到 Handler，这个 Handler 的 handleMessage() 方法是在主线程调用的，所以消息就从异步线程切换到了主线程。 2.3 图解原理 文字版的原理解析到这里就结束了，如果你看到这里还是没有懂，没关系，我特意给你们准备了些图，配合着前面几个章节，再多看几遍，一定可以吃透。 图片来源见【6】 2.4 小结 Handler 的背后有着 Looper 以及 MessageQueue 的协助，三者通力合作，分工明确。 尝试小结一下它们的职责，如下： Looper ：负责关联线程以及消息的分发在该线程下**从 MessageQueue 获取 Message，分发给 Handler ； MessageQueue ：是个队列，负责消息的存储与管理，负责管理由 Handler 发送过来的 Message ； Handler : 负责发送并处理消息，面向开发者，提供 API，并隐藏背后实现的细节。 对【2】章节提出的问题用一句话总结： Handler 发送的消息由 MessageQueue 存储管理，并由 Loopler 负责回调消息到 handleMessage()。 线程的转换由 Looper 完成，handleMessage() 所在线程由 Looper.loop() 调用者所在线程决定。 3. Handler 的延伸 Handler 虽然简单易用，但是要用好它还是需要注意一点，另外 Handler相关 还有些鲜为人知的知识技巧，比如 IdleHandler。 由于 Handler 的特性，它在 Android 里的应用非常广泛，比如： AsyncTask、HandlerThread、Messenger、IdleHandler 和 IntentService 等等。 这些我会讲解一些，我没讲到的可以自行搜索相关内容进行了解。 3.1 Handler 引起的内存泄露原因以及最佳解决方案 Handler 允许我们发送延时消息，如果在延时期间用户关闭了 Activity，那么该 Activity 会泄露。 这个泄露是因为 Message 会持有 Handler，而又因为 Java 的特性，内部类会持有外部类，使得 Activity 会被 Handler 持有，这样最终就导致 Activity 泄露。 解决该问题的最有效的方法是：将 Handler 定义成静态的内部类，在内部持有 Activity 的弱引用，并及时移除所有消息。 示例代码如下： private static class SafeHandler extends Handler { private WeakReference ref; public SafeHandler(HandlerActivity activity) { this.ref = new WeakReference(activity); } @Override public void handleMessage(final Message msg) { HandlerActivity activity = ref.get(); if (activity != null) { activity.handleMessage(msg); } } } 复制代码 并且再在 Activity.onDestroy() 前移除消息，加一层保障： @Override protected void onDestroy() { safeHandler.removeCallbacksAndMessages(null); super.onDestroy(); } 复制代码 这样双重保障，就能完全避免内存泄露了。 注意：单纯的在 onDestroy 移除消息并不保险，因为 onDestroy 并不一定执行。 3.2 为什么我们能在主线程直接使用 Handler，而不需要创建 Looper ？ 前面我们提到了每个Handler 的线程都有一个 Looper ，主线程当然也不例外，但是我们不曾准备过主线程的 Looper 而可以直接使用，这是为何？ 注意：通常我们认为 ActivityThread 就是主线程。事实上它并不是一个线程，而是主线程操作的管理者，所以吧，我觉得把 ActivityThread 认为就是主线程无可厚非，另外主线程也可以说成 UI 线程。 在 ActivityThread.main() 方法中有如下代码： //android.app.ActivityThread public static void main(String[] args) { //... Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) { sMainThreadHandler = thread.getHandler(); } //... Looper.loop(); throw new RuntimeException(\"Main thread loop unexpectedly exited\"); } 复制代码 Looper.prepareMainLooper(); 代码如下： /** * Initialize the current thread as a looper, marking it as an * application's main looper. The main looper for your application * is created by the Android environment, so you should never need * to call this function yourself. See also: {@link #prepare()} */ public static void prepareMainLooper() { prepare(false); synchronized (Looper.class) { if (sMainLooper != null) { throw new IllegalStateException(\"The main Looper has already been prepared.\"); } sMainLooper = myLooper(); } } 复制代码 可以看到在 ActivityThread 里 调用了 Looper.prepareMainLooper() 方法创建了 主线程的 Looper ,并且调用了 loop() 方法，所以我们就可以直接使用 Handler 了。 注意：Looper.loop() 是个死循环，后面的代码正常情况不会执行。 3.3 主线程的 Looper 不允许退出 如果你尝试退出 Looper ，你会得到以下错误信息： Caused by: java.lang.IllegalStateException: Main thread not allowed to quit. at android.os.MessageQueue.quit(MessageQueue.java:415) at android.os.Looper.quit(Looper.java:240) 复制代码 why? 其实原因很简单，主线程不允许退出，退出就意味 APP 要挂。 3.4 Handler 里藏着的 Callback 能干什么？ 在 Handler 的构造方法中有几个 要求传入 Callback ，那它是什么，又能做什么呢？ 来看看 Handler.dispatchMessage(msg) 方法： public void dispatchMessage(Message msg) { //这里的 callback 是 Runnable if (msg.callback != null) { handleCallback(msg); } else { //如果 callback 处理了该 msg 并且返回 true， 就不会再回调 handleMessage if (mCallback != null) { if (mCallback.handleMessage(msg)) { return; } } handleMessage(msg); } } 复制代码 可以看到 Handler.Callback 有优先处理消息的权利 ，当一条消息被 Callback 处理并拦截（返回 true），那么 Handler 的 handleMessage(msg) 方法就不会被调用了；如果 Callback 处理了消息，但是并没有拦截，那么就意味着一个消息可以同时被 Callback 以及 Handler 处理。 这个就很有意思了，这有什么作用呢？ 我们可以利用 Callback 这个拦截机制来拦截 Handler 的消息！ 场景：Hook ActivityThread.mH ， 在 ActivityThread 中有个成员变量 mH ，它是个 Handler，又是个极其重要的类，几乎所有的插件化框架都使用了这个方法。 3.5 创建 Message 实例的最佳方式 由于 Handler 极为常用，所以为了节省开销，Android 给 Message 设计了回收机制，所以我们在使用的时候尽量复用 Message ，减少内存消耗。 方法有二： 通过 Message 的静态方法 Message.obtain(); 获取； 通过 Handler 的公有方法 handler.obtainMessage(); 。 3.6 子线程里弹 Toast 的正确姿势 当我们尝试在子线程里直接去弹 Toast 的时候，会 crash ： java.lang.RuntimeException: Can't create handler inside thread that has not called Looper.prepare() 复制代码 本质上是因为 Toast 的实现依赖于 Handler，按子线程使用 Handler 的要求修改即可（见【2.1】），同理的还有 Dialog。 正确示例代码如下： new Thread(new Runnable() { @Override public void run() { Looper.prepare(); Toast.makeText(HandlerActivity.this, \"不会崩溃啦！\", Toast.LENGTH_SHORT).show(); Looper.loop(); } }).start(); 复制代码 3.7 妙用 Looper 机制 我们可以利用 Looper 的机制来帮助我们做一些事情： 将 Runnable post 到主线程执行； 利用 Looper 判断当前线程是否是主线程。 完整示例代码如下： public final class MainThread { private MainThread() { } private static final Handler HANDLER = new Handler(Looper.getMainLooper()); public static void run(@NonNull Runnable runnable) { if (isMainThread()) { runnable.run(); }else{ HANDLER.post(runnable); } } public static boolean isMainThread() { return Looper.myLooper() == Looper.getMainLooper(); } } 复制代码 能够省去不少样板代码。 4. 知识点汇总 由前文可得出一些知识点，汇总一下，方便记忆。 Handler 的背后有 Looper、MessageQueue 支撑，Looper 负责消息分发，MessageQueue 负责消息管理； 在创建 Handler 之前一定需要先创建 Looper； Looper 有退出的功能，但是主线程的 Looper 不允许退出； 异步线程的 Looper 需要自己调用 Looper.myLooper().quit(); 退出； Runnable 被封装进了 Message，可以说是一个特殊的 Message； Handler.handleMessage() 所在的线程是 Looper.loop() 方法被调用的线程，也可以说成 Looper 所在的线程，并不是创建 Handler 的线程； 使用内部类的方式使用 Handler 可能会导致内存泄露，即便在 Activity.onDestroy 里移除延时消息，必须要写成静态内部类； 5. 总结 作者：程序亦非猿 链接：https://juejin.im/post/5c74b64a6fb9a049be5e22fc 来源：掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 "},"源码分析/LruCache.html":{"url":"源码分析/LruCache.html","title":"LruCache","keywords":"","body":"LruCache 内部通过LinkedHashMap实现，内部有size，maxSize等关键属性，使用时可以直接创建LruCache对象并传入maxSize；或者继承LruCache重写关键方法。 "},"源码分析/View.html":{"url":"源码分析/View.html","title":"View","keywords":"","body":"View "},"源码分析/触摸事件分发机制.html":{"url":"源码分析/触摸事件分发机制.html","title":"触摸事件分发机制","keywords":"","body":"触摸事件分发机制 参考：Android事件分发机制详解：史上最全面、最易懂 触摸事件传递顺序 Activity -> ViewGroup -> View 事件分发核心方法 dispatchTouchEvent, onInterceptorTouchEvent, onTouchEvent. "},"逆向.html":{"url":"逆向.html","title":"逆向","keywords":"","body":"逆向 "},"硬件和传感器.html":{"url":"硬件和传感器.html","title":"硬件和传感器","keywords":"","body":"硬件和传感器 "},"多媒体.html":{"url":"多媒体.html","title":"多媒体","keywords":"","body":"多媒体 "},"OpenGL.html":{"url":"OpenGL.html","title":"OpenGL","keywords":"","body":"OpenGL "},"官方库/readme.html":{"url":"官方库/readme.html","title":"官方库","keywords":"","body":"官方库 "},"官方库/RecyclerView.html":{"url":"官方库/RecyclerView.html","title":"RecyclerView","keywords":"","body":"RecyclerView DiffUtil 最大的用处就是在RecyclerView刷新时，不再无脑mAdapter.notifyDataSetChanged() 它会自动计算新老数据集的差异，并根据差异情况，自动调用以下四个方法 adapter.notifyItemRangeInserted(position, count); adapter.notifyItemRangeRemoved(position, count); adapter.notifyItemMoved(fromPosition, toPosition); adapter.notifyItemRangeChanged(position, count, payload); 1. 基本用法 实现DiffUtil.Callback，然后调用DiffUtil.calculateDiff()方法，计算出新老数据集转化的最小更新集，就是DiffUtil.DiffResult对象。 然后调用DiffUtil.DiffResult.dispatchUpdatesTo（RecyclerView.Adapter adapter）方法，传入RecyclerView的Adapter，最后，更新数据集即可。 //示例步骤： public class StudentDiffCallback extends DiffUtil.Callback { private List oldList; private List list; public StudentDiffCallback(List oldList, List list) { this.oldList = oldList; this.list = list; } @Override public int getOldListSize() { return oldList.size(); } @Override public int getNewListSize() { return list.size(); } @Override public boolean areItemsTheSame(int i, int i1) { return oldList.get(i).id == list.get(i1).id; } @Override public boolean areContentsTheSame(int i, int i1) { Student oldStudent = oldList.get(i); Student student = list.get(i1); return oldStudent.id == student.id && oldStudent.age == student.age && oldStudent.name.equals(student.name); } } //使用步骤 DiffUtil.DiffResult diffResult = DiffUtil.calculateDiff(new StudentDiffCallback(adapter.getDatas(), list)); diffResult.dispatchUpdatesTo(adapter); adapter.updateList(list); 2.高级用法 高级用法只涉及到两个方法， 我们需要分别实现DiffUtil.Callback.getChangePayload(int oldItemPosition, int newItemPosition)， 返回的Object就是表示Item改变了哪些内容。 再配合RecyclerView.Adapter.onBindViewHolder(VH holder, int position, List payloads)方法， 完成定向刷新。 payloads 参数 是一个从（notifyItemChanged(int, Object)或notifyItemRangeChanged(int, int, Object)）里得到的合并list。 如果payloads list 不为空，那么当前绑定了旧数据的ViewHolder 和Adapter， 可以使用 payload的数据进行一次 高效的部分更新。 如果payload 是空的，Adapter必须进行一次完整绑定（调用两参方法）。 //示例代码 @Nullable @Override public Object getChangePayload(int oldItemPosition, int newItemPosition) { // 定向刷新中的部分更新,效率最高 //只是没有了ItemChange的白光一闪动画，（反正我也觉得不太重要） TestBean oldBean = mOldDatas.get(oldItemPosition); TestBean newBean = mNewDatas.get(newItemPosition); //这里就不用比较核心字段了,一定相等 Bundle payload = new Bundle(); if (!oldBean.getDesc().equals(newBean.getDesc())) { payload.putString(\"KEY_DESC\", newBean.getDesc()); } if (oldBean.getPic() != newBean.getPic()) { payload.putInt(\"KEY_PIC\", newBean.getPic()); } if (payload.size() == 0)//如果没有变化 就传空 return null; return payload;// } //在Adapter里如下重写三参的onBindViewHolder： @Override public void onBindViewHolder(DiffVH holder, int position, List payloads) { if (payloads.isEmpty()) { onBindViewHolder(holder, position); } else { //文艺青年中的文青 Bundle payload = (Bundle) payloads.get(0); TestBean bean = mDatas.get(position); for (String key : payload.keySet()) { switch (key) { case \"KEY_DESC\": //这里可以用payload里的数据，不过data也是新的 也可以用 holder.tv2.setText(bean.getDesc()); break; case \"KEY_PIC\": holder.iv.setImageResource(payload.getInt(key)); break; default: break; } } } } //如果嫌麻烦可以这样写，当然这需要更新所有内容： @Nullable @Override public Object getChangePayload(int oldItemPosition, int newItemPosition) { return list.get(newItemPosition); } @Override public void onBindViewHolder(@NonNull ViewHolder holder, int position, @NonNull List payloads) { if (payloads.isEmpty()) { onBindViewHolder(holder, position); } else { convert(holder, getItemAt(position)); } } 注意1： 没有重写DiffUtil.Callback.getChangePayload(int oldItemPosition, int newItemPosition) 时，更新列表时，有数据更新的item会闪白光，如果不想要白光的话，重写这个方法即可。 注意2：如果数据量多比较耗时，计算新老数据集差异的逻辑可以写在子线程，然后再主线程更新，减少主线程开销。 RecyclerView的好伴侣：详解DiffUtil "},"第三方库/第三方库.html":{"url":"第三方库/第三方库.html","title":"第三方库","keywords":"","body":"第三方库 "},"第三方库/BlockCanary.html":{"url":"第三方库/BlockCanary.html","title":"BlockCanary","keywords":"","body":"BlockCanary 原理：巧妙的利用了Android原生Looper.loop中的一个log打印逻辑。 public static void loop() { final Looper me = myLooper(); if (me == null) { throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); } final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); // Allow overriding a threshold with a system prop. e.g. // adb shell 'setprop log.looper.1000.main.slow 1 && stop && start' final int thresholdOverride = SystemProperties.getInt(\"log.looper.\" + Process.myUid() + \".\" + Thread.currentThread().getName() + \".slow\", 0); boolean slowDeliveryDetected = false; for (;;) { Message msg = queue.next(); // might block if (msg == null) { // No message indicates that the message queue is quitting. return; } // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) { logging.println(\">>>>> Dispatching to \" + msg.target + \" \" + msg.callback + \": \" + msg.what); } // Make sure the observer won't change while processing a transaction. final Observer observer = sObserver; final long traceTag = me.mTraceTag; long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs; long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs; if (thresholdOverride > 0) { slowDispatchThresholdMs = thresholdOverride; slowDeliveryThresholdMs = thresholdOverride; } final boolean logSlowDelivery = (slowDeliveryThresholdMs > 0) && (msg.when > 0); final boolean logSlowDispatch = (slowDispatchThresholdMs > 0); final boolean needStartTime = logSlowDelivery || logSlowDispatch; final boolean needEndTime = logSlowDispatch; if (traceTag != 0 && Trace.isTagEnabled(traceTag)) { Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); } final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0; final long dispatchEnd; Object token = null; if (observer != null) { token = observer.messageDispatchStarting(); } long origWorkSource = ThreadLocalWorkSource.setUid(msg.workSourceUid); try { msg.target.dispatchMessage(msg); if (observer != null) { observer.messageDispatched(token, msg); } dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0; } catch (Exception exception) { if (observer != null) { observer.dispatchingThrewException(token, msg, exception); } throw exception; } finally { ThreadLocalWorkSource.restore(origWorkSource); if (traceTag != 0) { Trace.traceEnd(traceTag); } } if (logSlowDelivery) { if (slowDeliveryDetected) { if ((dispatchStart - msg.when) 这个log打印逻辑正是在Message消息分发前后，大部分的性能卡顿问题都是在这里发生的，监控这两个逻辑之间的时间差就可以得到当前主线程的卡顿状态，如果超时则获取trace信息并上报。具体实现在LooperMonitor。 优点 灵活配置可监控常见APP应用性能也可作为一部分场景的ANR监测，并且可以准确定位ANR和耗时调用栈。 缺点 BlockCanary应用在ANR监控上有几个比较严重的问题 1、 谷歌已经明确标注This must be in a local variable, in case a UI event sets the logger这个looger对象是可以被更改的，已经有开发者遇到在使用WebView时logger被set为Null导致BlockCanary失效，只能让BlockCanary在WebView初始化之后调用start。 2、 如果dispatchMessage执行的非常久是无法触发BlockCanary的逻辑。在Activity中重写dispatchTouchEvent和dispatchKeyEvent，模拟耗时操作，弹出ANR告警，但BlockCanary没有任何反应。 3、 无法监控CPU资源紧张造成系统卡顿，无法响应的ANR。 "},"第三方库/LeakCanary.html":{"url":"第三方库/LeakCanary.html","title":"LeakCanary","keywords":"","body":"LeakCanary 使用 添加依赖，在Application.onCreate中加入如下代码： if(LeakCanary.isInAnalyzerProcess(this)){ return; } LeakCanary.install(this); 工作原理： RefWatcher.watch() 创建一个 KeyedWeakReference 到要被监控的对象。 然后在后台线程检查引用是否被清除，如果没有，调用GC。 如果引用还是未被清除，把 heap 内存 dump 到 APP 对应的文件系统中的一个 .hprof 文件中。 在另外一个进程中的 HeapAnalyzerService 有一个 HeapAnalyzer 使用HAHA 解析这个文件。 得益于唯一的 reference key, HeapAnalyzer 找到 KeyedWeakReference，定位内存泄漏。 HeapAnalyzer 计算 到 GC roots 的最短强引用路径，并确定是否是泄漏。如果是的话，建立导致泄漏的引用链。 引用链传递到 APP 进程中的 DisplayLeakService， 并以通知的形式展示出来。 "},"第三方库/OkHttp.html":{"url":"第三方库/OkHttp.html","title":"OkHttp","keywords":"","body":"OkHttp 参考：彻底理解OkHttp - OkHttp 源码解析及OkHttp的设计思想 用法 创建OkHttp实例，可通过OkHttpClient.Builder添加拦截器等自定配置 请求网络，可以同步/异步 Request request = new Request.Builder().url(url).build(); //同步 Response response = okHttpClient.newCall(request).execute()； response.body().string(); //异步 okHttpClient.newCall(request).enqueue(); OkHttp大致执行流程 通过OkHttpClient.newCall内部的RealCall发起网络请求（execute同步请求和enqueue异步请求，异步请求有DIspatcher进行分发），getResponseWithInterceptorChain，RetryAndFollowUpInterceptors, 以及BridgeInterceptor, CacheInterceptor, ConnectInterceptor, NetworkInterceptor, CallServerInterceptor进行请求处理，最后返回请求结果，请求结束。 "},"第三方库/RxJava.html":{"url":"第三方库/RxJava.html","title":"RxJava 2","keywords":"","body":"RxJava 2 参考：Rxjava 2.x 源码系列 - 基础框架分析 "},"第三方库/Glide.html":{"url":"第三方库/Glide.html","title":"Glide","keywords":"","body":"Glide 坑 默认情况下，固定链接图片加载后，加载的是缓存的图片，不是网络最新图片，需要设置缓存策略为不使用本地缓存 图片拉伸问题 解决方案：（在我手机上没发现这问题，解决方案不确定是否有效） 1、取消使用place holder： Glide.with(context).load(resId). into(imageView); 2、使用place holder加上dontAnimate()： Glide.with(context).load(resId).placeholder(defaultId).dontAnimate().into(imageView); 3、使用asBitmap加载： Glide.with(context).load(imageUrl).asBitmap().placeholder(defaultId).into(imageView); Glide加载框架生命周期问题：可能Activity中加载图片需要用applicationContext 可以在application中预先初始化：Glide.get(this) "},"测试.html":{"url":"测试.html","title":"测试","keywords":"","body":"测试 "},"Kotlin/readme.html":{"url":"Kotlin/readme.html","title":"Kotlin","keywords":"","body":"Kotlin https://www.kotlincn.net "},"Kotlin/Kotlin data class 和 Gson, @parcelize问题.html":{"url":"Kotlin/Kotlin data class 和 Gson, @parcelize问题.html","title":"Kotlin data class 和 Gson, @parcelize问题","keywords":"","body":"Kotlin data class 和 Gson, @parcelize问题 gson 扩展方法 inline fun Gson.fromJson(json: String) = fromJson(json, T::class.java) @parcelize 需要在build.gradle android内设置属性 ​ androidExtensions { experimental = true } 例子： //正确的data class写法 @Parcelize data class Student( var age: Int = 0, var name: String? = null, var toy: Toy? = null ) : Parcelable { } @Parcelize data class Toy( var price: Int = 0, var name: String? = null ) : Parcelable { } //错误的data class写法，类体内的name不会序列化，别的地方使用获取到的是null，kotlin bytecode，decompile文件可以看到 @parcelize data class Student( var age: Int = 0): Parcelable { var name: String? = null } gson解析 val student2 = gson.fromJson(\"{\\n\" + \"\\t\\\"age\\\":10,\\n\" + \"\\t\\\"name\\\":\\\"json name\\\",\\n\" + \"\\t\\\"toy\\\":{\\n\" + \"\\t\\t\\\"name\\\":\\\"toy\\\",\\n\" + \"\\t\\t\\\"price\\\":1000\\n\" + \"\\t}\\n\" + \"}\", Student::class.java) intent.putExtra(\"student2\", student2) "},"Kotlin/Kotlin中class javaClass等真实类型.html":{"url":"Kotlin/Kotlin中class javaClass等真实类型.html","title":"Kotlin中::class javaClass等真实类型","keywords":"","body":"Kotlin中::class javaClass等真实类型 除了A::class.java，a.javaClass是Class类型，其他的都是Kotlin中的类型 "},"Kotlin/Kotlin注解.html":{"url":"Kotlin/Kotlin注解.html","title":"Kotlin注解","keywords":"","body":"Kotlin注解 @SinceKotlin(\"1.1\") Kotlin1.1可用 "}}