# 深入理解Java虚拟机2



## Java体系和发展史

### Java技术体系

![img](https://upload-images.jianshu.io/upload_images/1621638-231a6896feb2c7ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/750/format/webp)



## JVM运行时数据区域

- **程序计数器**：是一块较小的内存空间，是当前线程所执行的字节码的行号指示器。唯一一个没有OOM的内存区域。
-  **Java虚拟机栈**：生命周期与线程相同。描述的是Java方法执行的内存模型：每个方法执行时都会创建一个栈帧，用于存储局部变量表、操作栈、动态链接、方法出口等信息。一个方法被调用执行的过程就是栈帧在虚拟机栈中从入栈到出栈的过程。

> ```
> 成员变量：
> 
> * 成员变量定义在类中，在整个类中都可以被访问。
> 
> * 成员变量随着对象的建立而建立，随着对象的消失而消失，存在于对象所在的堆内存中。
> 
> * 成员变量有默认初始化值。
> 
> 局部变量：
> 
> * 局部变量只定义在局部范围内，如：函数内，语句内等，只在所属的区域有效。
> 
> * 局部变量存在于栈内存中，作用的范围结束，变量空间会自动释放。
> 
> * 局部变量没有默认初始化值
> ```
>
> 

- **本地方法栈**：和java虚拟机栈作用类似，只不过java虚拟机栈为虚拟机执行java方法服务，而本地方法栈为虚拟机使用到的Native方法服务。有些虚拟机把java虚拟机栈和本地方法栈合二为一了。
- **Java堆**：几乎所有的对象实例都在这里分配内存。是垃圾收集器管理的主要区域，因此也叫“GC堆”，还好没叫垃圾堆。虽然是线程共享，也可能划分多个线程私有的分配缓冲区（TLAB）。从垃圾收集器算法角度可以把堆分成：新生代和老年代；在细点可以有Eden空间、From Survivor空间、To Survivor空间等。当前虚拟机堆都是可扩展的，可通过-Xmx最大值和-Xms最小值控制，设置成一样可避免堆自动扩展。
- **方法区**：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译的代码等数据。



![img](https:////upload-images.jianshu.io/upload_images/1621638-7821a8f38bf81428.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/492/format/webp)

程序计数器、虚拟机栈、本地方法栈三个区域随线程生而生，虽线程灭而灭。其中栈帧随着方法的进入和退出而有条不紊的执行着入栈和出栈操作。每个栈帧分配多少内存在类结构确定下来时就已知了，这几个区域内存分配和回收都具有稳定性，不需要过多考虑回收问题，线程灭就自动回收了。java堆和方法区的内存都是动态分配和回收的。方法区进行垃圾收集“性价比”比较低，主要还是管理Java堆。



## 对象访问

主流的访问方式有两种：句柄和直接指针。在各种语言和框架中这两种访问方式都很常见，各有千秋。

**句柄访问**
 java堆中划出一块内存作为句柄池，句柄中包含对象实例数据和类型数据各自的具体地址信息。最大的好处就是reference中存储的是稳定的句柄地址，在对象被移动的时候只改变句柄的实例数据指针。（垃圾收集时移动对象是非常常见的现象）



![img](https:////upload-images.jianshu.io/upload_images/1621638-824525d288c55779.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/748/format/webp)



**直接指针**
 Java堆中的对象布局必须考虑如何防止类型数据地址。reference中存储的直接就是对象地址。最大的好处就是速度快，节省一次指针定位的时间开销。



![img](https:////upload-images.jianshu.io/upload_images/1621638-d0acbbe6d785aa3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/774/format/webp)

## 引用

引用：	当reference类型的数据中存储的数值代表的是另一块内存的起始地址，就称其为引用。引用有如下4中类型：

- **强引用**：只要强引用还存在，GC永远不会回收被引用的对象；
- **软引用**(SoftReference)：描述一些还有用，但不是必须的对象。对于只有软引用的对象，内存不足时，在OOM之前会被回收。
- **弱引用**(WeakReference)：描述的也是非必须的对象，但程度比软引用弱。只能存活到下次垃圾收集器工作之前，也就是说只要垃圾收集器工作，这种引用的对象都会被回收，不管当前内存是否足够。
- **虚引用**(PhantomReference)：又称幽灵引用或者幻影引用。它是最弱的一种引用关系。虚引用不会影响对象的生存时间，通过虚引用也无法获取对象实例。设置虚引用的唯一目的就是在对象对收集器回收时收到一个系统的通知。



## OutOfMemoryError异常

Java虚拟机规范的描述中，除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError的可能



## 垃圾收集器

#### 确定对象是否已死

- **引用计数器**：给对象添加一个引用计数器，每当有地方引用对象时，计数器就加1，当引用失效时，计数器就减1。当计数器等于0时，对象就不再可能被使用了。
   优点：实现简单，判定效率高。
   缺点：很难解决对象间循环引用的问题。
- **根搜索算法**：通过一系列名为“GC Roots”的对象作为起点向下搜索，搜索所走过的路径成为引用链。当一个对象到GC Roots没有任何引用链时，则证明这个对象不再可能被使用了。

> 在Java中可作为GC Roots的对象有：
>
> * 虚拟机栈中引用的对象（栈帧中本地变量表）
>
> * 方法区中的类静态属性引用的对象
>
> * 方法区中的常量引用的对象
>
> * 本地方法栈帧中JNI引用的对象

收集器判断对象不可达后，会检查对象的finalize()方法是否被执行过，如果没有就先执行finalize()。一个对象的finalize()只会被执行一次，如果一个对象在finalize()方法中被救活了，即重新被引用了，当它再次不可达时不会执行finalize()方法了。

#### 垃圾收集算法

-  **标记-清除算法**(Mark-Sweep)：顾名思义收集分为“标记”和“清除”两个阶段。标记就是上面介绍的标记对象死亡的过程。

> 优点：这是最基础的收集算法，其他的算法都是它的基础上演变来的。
>  缺点：1、效率问题，标记和清除效率都不高；2、空间问题，标记清除后产生大量的不连续的内存碎片。

-  **复制算法**(Copying)：将内存分成大小相等的A、B两块，每次只使用其中一块，比如A，当A使用完了，就把还存活的对象拷到B上，然后把A空间一次清掉。

> 优点：实现简单、运行效率高。
>  缺点：可使用的内存缩小为原来的一半
>  改进：IBM研究表面，新生代中98%的对象都是朝生夕死，所以并不需要1：1来划分。所以分成一块较大的Eden空间和a、b两块较小的Survivor空间（Eden:Survivor = 8:1）。每次使用Eden和一块Survivor空间，比如Survivor-a，用完了就把存活的对象拷到Survivor-b上，然后清除Eden和Survivor-a，然后再使用Eden和Survivor-b。每次浪费10%的空间，如果存活对象大于10%就把多出来的对象放到给新生代担保的老年代。

目前商业虚拟机都采用改进后的复制算法回收新生代。

- **标记-整理算法**(Mark-Compact)：标记还是对象标记的那个标记。整理是把存活的对象移动到内存的一端，然后清理掉端边界以外的内存。
- **分代收集算法**(Generational Collection)：这个算法没有新思想。只是根据对象存活周期将内存划分成新生代和老年代两块。然后不同的年代采用不同收集算法，新生代用复制算法，老年代因为没有额外空间给它内存担保，而且对象存活时间长，那就用标记-整理或者标记-清除。



## 虚拟机性能监控与故障处理工具

### JDK的命令行工具

### JDK的可视化工具



## Class类文件结构

## 字节码指令简介



## 虚拟机类加载机制

Class文件需要被加载到虚拟机中才能被运行和使用。**生命周期包括：加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)七个阶段。**

#### 类加载器

虚拟机中类的唯一性由类本身和它的加载器决定。

双亲委派模型的父子关系不是继承，而是组合关系。



![img](https:////upload-images.jianshu.io/upload_images/1621638-84ffc6d9427bcc99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/484/format/webp)

双亲委派模型

双亲委派模型的工作工程：类加载器收到类加载请求时，首先不会尝试自己加载这个类，而是把这个请求委派给父类加载器去完成，每一层加载器都是如此，所以所有的加载请求都会传递到启动类加载器，只有父加载器反馈自己无法完成这个加载请求时（它的搜索范围中没有找到所需的类），子加载器才会尝试自己去加载。



## 虚拟机字节码执行引擎



## 程序编译与代码优化

### 早期优化（编译期）

Java语法糖

1. 泛型与类型擦除：Java泛型只在程序源码中存在，编译后的字节码文件中，已经替换成原来的原生类型了，并在相应地方加入了强制类型转换。因此，对于运行期的Java语言来说，ArrayList<Integer> 和 ArrayList<String> 就是同一个类。所以泛型是Java的一个语法糖，这种泛型被称为伪泛型

   ```java
           //类型擦除
           Map<String, String> map = new HashMap<>();
           map.put("hello", "你好");
           map.put("how are you?", "吃了没？");
           System.out.println(map.get("hello"));
           System.out.println(map.get("how are you?"));
   ```

   

2. 自动装箱，拆箱与遍历循环。使用最多的语法糖

```java
        //装箱拆箱
        List<Integer> list = Arrays.asList(1, 2, 3, 4);
        list.add(5);
        int sum = 0;
        for(int i : list) {
            sum += i;
        }
        System.out.println(sum);

		//class文件内容：没有《深入理解Java虚拟机2》中的Arrays.asList装箱
        List<Integer> list = Arrays.asList(1, 2, 3, 4);
        list.add(5);
        int sum = 0;

        int i;
        for(Iterator var4 = list.iterator(); var4.hasNext(); sum += i) {
            i = (Integer)var4.next();
        }

        System.out.println(sum);
```



```java
	//自动装箱的陷阱
	//JDK8，Idea中会有提示：Number objects are compared using '==', not 'equals()' less...  
    public static void main(String[] args) {
        Integer a = 1;
        Integer b = 2;
        Integer c = 3;
        Integer d = 3;
        Integer e = 321;
        Integer f = 321;
        Long g = 3L;
        System.out.println(c == d);
        System.out.println(e == f);
        System.out.println(c == (a + b));
        System.out.println(c.equals(a + b));
        System.out.println(g == (a + b));
        System.out.println(g.equals(a + b));
    }
	//输出结果：
    true
    false
    true
    true
    true
    false
```

3. 条件编译：使用条件为常量的if语句，编译期间就会处理。**只有条件为常量的if才能有这个效果，其他while等的都不可以**

```java
public class ConditionCompile {
    public static void main(String[] args) {
        if(true) {
            System.out.println("true");
        } else {
            System.out.println("false");
        }
    }
}

//编译后的class文件
public class ConditionCompile {
    public ConditionCompile() {
    }

    public static void main(String[] args) {
        System.out.println("true");
    }
}
```



```

```



### 晚期优化（运行期）[参考](https://blog.csdn.net/wobushixiaobailian/article/details/83990753)

主要是编译器，即时编译器，解释器是否存在及其原因，以及各个虚拟机实现的不同

#### HotSpot虚拟机即时编译器４大问题解决-即时编译器的学习

1.为何HotSpot虚拟机要使用解释器与编译器并存的架构?
　　尽管不是所有的java虚拟机都采用解释器和编译器并存的架构，但许多主流的商用虚拟机，如HotSpot,J9等，都同时包含解释器和编译器。解释器与编译器两者各有优势:当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译时间，立即执行。在程序运行后，随着时间的退役，编译器逐渐发挥作用，把越来越多的代码编译成本地代码只有可以获取更好的性能。当程序运行环境中内存资源限制较大，可以使用解释器执行节约内存，反之可以使用编译执行来提升效率。同时，解释器还可以作为编译器激进优化时的一个逃生门，让编译器根据概率选择一些大多数时候都能提升运行速度的优化手段，当激进优化的假设不成立，会通过逆优化退回到解释状态继续执行。在整个架构中，解释器和编译器经常配合工作，这就使为什么要使用并存架构的原因。

2.为何HotSpot虚拟机要实现两个不同的编译器?
　　在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server Compiler，但大多数情况下我们简称为C1编译器和C2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：

　　-client：指定Java虚拟机运行在Client模式下，并使用C1编译器；

　　-server：指定Java虚拟机运行在Server模式下，并使用C2编译器。

　　除了可以显式指定Java虚拟机在运行时到底使用哪一种即时编译器外，默认情况下HotSpot VM则会根据操作系统版本与物理机器的硬件性能自动选择运行在哪一种模式下，以及采用哪一种即时编译器。简单来说，C1编译器会对字节码进行简单和可靠的优化，以达到更快的编译速度；而C2编译器会启动一些编译耗时更长的优化，以获取更好的编译质量。不过在Java7版本之后，一旦开发人员在程序中显式指定命令“-server”时，缺省将会开启分层编译（Tiered Compilation）策略，由C1编译器和C2编译器相互协作共同来执行编译任务。不过在早期版本中，开发人员则只能够通过命令“-XX:+TieredCompilation”手动开启分层编译策略。编译层次包括：

　　第0层,程序解释执行，解释器不开启性能监控，可触发第1层。

　　第1层，也称为C1编译，将字节码编译为本地代码，进行简单，可靠的优化，如有必要将加入性能监控的逻辑。

　　第2层,C2编译，将字节码编译为本地代码，但是会启用一些编译耗时较长的优化。

用C1获取更高的便以速度，用C2获取更好的编译质量，这就是原因。

程序何时使用解释器执行？何时使用编译器执行？
　　一般的代码都是使用解释器执行，当代码变为热点代码的时候就会被JIT执行。

　　热点代码有两类：被多次调用的方法和被多次执行的循环体。

　　而判断一个方法为热点代码的量化标准，有两种方法： 
>
> 1） 基于采样的热点探测。周期性的探测各线程的栈顶方法，找出出现频率高的。这种方法并不准备，结果容易受干扰（如线程等待） 
>
> 2） 基于计数器的热点探测。为每个方法保留一个计数器，统计被调用的次数，若超过某个“阀值”，则断定为热点方法。因此，在每个方法入口，都会判断是否有翻译过的代码，若没有，则计数器加一，判断是否超过“阀值”，若超过，则为热点代码，保留其编译后的代码。流程如下： 
> 方法调用计数器client默认1500次，server默认10000次，可以通过参数-XX:CompileThreshold来设定。调用方法时，会先判断是否存在编译过的版本，如果有则调用该版本，否则计数器加1，然后看方法调用计数器和回边计数器之和是否超过方法调用计数器的阈值。超过，则提交编译请求。

　　方法调用计数器并不是统计方法调用绝对次数，而是一个相对执行频率，超过一定时间，如果方法调用次数不足以让它提交给编译器，则计数器就会被减少一半，这种现象称为热度衰减(Counter Decay)，进行热度衰减的动作是在垃圾回收时顺便进行的，而这段时间就被称为半衰周期（Counter Half Life Time）可用-XX:-UseCounterDecay来关闭热度衰减，用-XX:CounterHalfLifeTime来设置半衰时间。

回边计数器用于统计方法中循环体的执行次数。字节码遇到控制流向后跳转 的指令成为回边。建立回边计数器统计的目的就是为了触发OSR编译(栈上替换)。回边的控制参数有：

-XX:BackEdgeThreshold,-XX:OnStackReplacePercentage。



哪些程序代码会被编译成本地代码?如何编译为本地代码?
哪些代码:当向编译器提交编译请求的那些代码。 
　　简单来说C1和C2两个编译过程不同。 
　　C1:简单快速三段式编译，主要关注局部的优化，放弃全局优化。 

​	C2:专门面向服务端的典型应用并未服务端的性能配置特别调整过的编译器。



# [参考：《深入理解Java虚拟机》读书笔记7：高效并发](https://www.jianshu.com/p/46a2595ebe79)